schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "accounts"
"""
type accounts {
  access_token: String
  expires_at: Int
  id: uuid!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!

  """An object relationship"""
  provider_type: provider_type!
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

input accounts_aggregate_bool_exp {
  count: accounts_aggregate_bool_exp_count
}

input accounts_aggregate_bool_exp_count {
  arguments: [accounts_select_column!]
  distinct: Boolean
  filter: accounts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"""
order by aggregate values of table "accounts"
"""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"""
input type for inserting array relation for remote table "accounts"
"""
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""aggregate avg on columns"""
type accounts_avg_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by avg() on columns of table "accounts"
"""
input accounts_avg_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  access_token: String_comparison_exp
  expires_at: Int_comparison_exp
  id: uuid_comparison_exp
  id_token: String_comparison_exp
  oauth_token: String_comparison_exp
  oauth_token_secret: String_comparison_exp
  provider: String_comparison_exp
  providerAccountId: String_comparison_exp
  provider_type: provider_type_bool_exp
  refresh_token: String_comparison_exp
  refresh_token_expires_in: bigint_comparison_exp
  scope: String_comparison_exp
  session_state: String_comparison_exp
  token_type: String_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  expires_at: Int
  refresh_token_expires_in: bigint
}

"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  access_token: String
  expires_at: Int
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  provider_type: provider_type_obj_rel_insert_input
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type accounts_max_fields {
  access_token: String
  expires_at: Int
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""
order by max() on columns of table "accounts"
"""
input accounts_max_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""aggregate min on columns"""
type accounts_min_fields {
  access_token: String
  expires_at: Int
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""
order by min() on columns of table "accounts"
"""
input accounts_min_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts!]!
}

"""
input type for inserting object relation for remote table "accounts"
"""
input accounts_obj_rel_insert_input {
  data: accounts_insert_input!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}

"""Ordering options when selecting data from "accounts"."""
input accounts_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  provider_type: provider_type_order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: accounts"""
input accounts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "accounts"
"""
enum accounts_select_column {
  """column name"""
  access_token

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  id_token

  """column name"""
  oauth_token

  """column name"""
  oauth_token_secret

  """column name"""
  provider

  """column name"""
  providerAccountId

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expires_in

  """column name"""
  scope

  """column name"""
  session_state

  """column name"""
  token_type

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  access_token: String
  expires_at: Int
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""aggregate stddev on columns"""
type accounts_stddev_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev() on columns of table "accounts"
"""
input accounts_stddev_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate stddev_pop on columns"""
type accounts_stddev_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev_pop() on columns of table "accounts"
"""
input accounts_stddev_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate stddev_samp on columns"""
type accounts_stddev_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev_samp() on columns of table "accounts"
"""
input accounts_stddev_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_stream_cursor_value_input {
  access_token: String
  expires_at: Int
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: bigint
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""aggregate sum on columns"""
type accounts_sum_fields {
  expires_at: Int
  refresh_token_expires_in: bigint
}

"""
order by sum() on columns of table "accounts"
"""
input accounts_sum_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
update columns of table "accounts"
"""
enum accounts_update_column {
  """column name"""
  access_token

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  id_token

  """column name"""
  oauth_token

  """column name"""
  oauth_token_secret

  """column name"""
  provider

  """column name"""
  providerAccountId

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expires_in

  """column name"""
  scope

  """column name"""
  session_state

  """column name"""
  token_type

  """column name"""
  type

  """column name"""
  userId
}

input accounts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: accounts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_set_input

  """filter the rows which have to be updated"""
  where: accounts_bool_exp!
}

"""aggregate var_pop on columns"""
type accounts_var_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by var_pop() on columns of table "accounts"
"""
input accounts_var_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate var_samp on columns"""
type accounts_var_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by var_samp() on columns of table "accounts"
"""
input accounts_var_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate variance on columns"""
type accounts_variance_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by variance() on columns of table "accounts"
"""
input accounts_variance_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

type AggregateChatsWeaviate {
  """
  Aggregate this property"createdAt"
  """
  createdAt: AggregateChatsWeaviatecreatedAtObj

  """Indicates the group of returned data"""
  groupedBy: AggregateChatsWeaviateGroupedByObj

  """
  An object used to Get Meta information about Objects on a local Weaviate
  """
  meta: AggregateChatsWeaviateMetaObject

  """
  Aggregate this property"title"
  """
  title: AggregateChatsWeaviatetitleObj

  """
  Aggregate this property"userId"
  """
  userId: AggregateChatsWeaviateuserIdObj
}

"""An object containing Aggregation information about this property"""
type AggregateChatsWeaviatecreatedAtObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateChatsWeaviatecreatedAtTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateChatsWeaviatecreatedAtTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""An object containing the path and value of the grouped property"""
type AggregateChatsWeaviateGroupedByObj {
  """The path of the grouped property"""
  path: [String]

  """The value of the grouped property"""
  value: String
}

type AggregateChatsWeaviateMetaObject {
  count: Int
}

input AggregateChatsWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateChatsWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateChatsWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input AggregateChatsWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateChatsWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateChatsWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateChatsWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: AggregateChatsWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: AggregateChatsWeaviateMoveTo
}

"""An object containing Aggregation information about this property"""
type AggregateChatsWeaviatetitleObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateChatsWeaviatetitleTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateChatsWeaviatetitleTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""An object containing Aggregation information about this property"""
type AggregateChatsWeaviateuserIdObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateChatsWeaviateuserIdTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateChatsWeaviateuserIdTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

type AggregateDocumentsWeaviates {
  """Indicates the group of returned data"""
  groupedBy: AggregateDocumentsWeaviatesGroupedByObj

  """
  An object used to Get Meta information about Objects on a local Weaviate
  """
  meta: AggregateDocumentsWeaviatesMetaObject

  """
  Aggregate this property"name"
  """
  name: AggregateDocumentsWeaviatesnameObj

  """
  Aggregate this property"userId"
  """
  userId: AggregateDocumentsWeaviatesuserIdObj
}

"""An object containing the path and value of the grouped property"""
type AggregateDocumentsWeaviatesGroupedByObj {
  """The path of the grouped property"""
  path: [String]

  """The value of the grouped property"""
  value: String
}

type AggregateDocumentsWeaviatesMetaObject {
  count: Int
}

input AggregateDocumentsWeaviatesMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateDocumentsWeaviatesMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateDocumentsWeaviatesMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input AggregateDocumentsWeaviatesMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateDocumentsWeaviatesMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateDocumentsWeaviatesMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

"""An object containing Aggregation information about this property"""
type AggregateDocumentsWeaviatesnameObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateDocumentsWeaviatesnameTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateDocumentsWeaviatesnameTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateDocumentsWeaviatesNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: AggregateDocumentsWeaviatesMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: AggregateDocumentsWeaviatesMoveTo
}

"""An object containing Aggregation information about this property"""
type AggregateDocumentsWeaviatesuserIdObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateDocumentsWeaviatesuserIdTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateDocumentsWeaviatesuserIdTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

type AggregateMessagesWeaviate {
  """
  Aggregate this property"chatId"
  """
  chatId: AggregateMessagesWeaviatechatIdObj

  """
  Aggregate this property"content"
  """
  content: AggregateMessagesWeaviatecontentObj

  """Indicates the group of returned data"""
  groupedBy: AggregateMessagesWeaviateGroupedByObj

  """
  An object used to Get Meta information about Objects on a local Weaviate
  """
  meta: AggregateMessagesWeaviateMetaObject
}

"""An object containing Aggregation information about this property"""
type AggregateMessagesWeaviatechatIdObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateMessagesWeaviatechatIdTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateMessagesWeaviatechatIdTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""An object containing Aggregation information about this property"""
type AggregateMessagesWeaviatecontentObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateMessagesWeaviatecontentTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateMessagesWeaviatecontentTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""An object containing the path and value of the grouped property"""
type AggregateMessagesWeaviateGroupedByObj {
  """The path of the grouped property"""
  path: [String]

  """The value of the grouped property"""
  value: String
}

type AggregateMessagesWeaviateMetaObject {
  count: Int
}

input AggregateMessagesWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateMessagesWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateMessagesWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input AggregateMessagesWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateMessagesWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateMessagesWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateMessagesWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: AggregateMessagesWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: AggregateMessagesWeaviateMoveTo
}

"""Hybrid search"""
input AggregateObjectsChatsWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input AggregateObjectsChatsWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

input AggregateObjectsChatsWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

input AggregateObjectsChatsWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input AggregateObjectsChatsWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input AggregateObjectsChatsWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: AggregateObjectsChatsWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: AggregateObjectsChatsWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateObjectsChatsWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsChatsWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsChatsWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsChatsWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsChatsWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsChatsWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsChatsWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsChatsWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input AggregateObjectsChatsWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsChatsWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsChatsWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsChatsWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsChatsWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsChatsWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsChatsWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsChatsWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum AggregateObjectsChatsWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Hybrid search"""
input AggregateObjectsDocumentsWeaviatesHybridInpObj {
  """Search weight"""
  alpha: Float

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input AggregateObjectsDocumentsWeaviatesNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

input AggregateObjectsDocumentsWeaviatesNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

input AggregateObjectsDocumentsWeaviatesWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input AggregateObjectsDocumentsWeaviatesWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input AggregateObjectsDocumentsWeaviatesWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: AggregateObjectsDocumentsWeaviatesWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: AggregateObjectsDocumentsWeaviatesWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateObjectsDocumentsWeaviatesWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsDocumentsWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsDocumentsWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsDocumentsWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsDocumentsWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsDocumentsWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsDocumentsWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsDocumentsWeaviates
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input AggregateObjectsDocumentsWeaviatesWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsDocumentsWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsDocumentsWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsDocumentsWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsDocumentsWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsDocumentsWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsDocumentsWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsDocumentsWeaviates
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum AggregateObjectsDocumentsWeaviatesWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Hybrid search"""
input AggregateObjectsMessagesWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input AggregateObjectsMessagesWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

input AggregateObjectsMessagesWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

input AggregateObjectsMessagesWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input AggregateObjectsMessagesWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input AggregateObjectsMessagesWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: AggregateObjectsMessagesWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: AggregateObjectsMessagesWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateObjectsMessagesWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsMessagesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsMessagesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsMessagesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsMessagesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsMessagesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsMessagesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsMessagesWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input AggregateObjectsMessagesWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsMessagesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsMessagesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsMessagesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsMessagesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsMessagesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsMessagesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsMessagesWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum AggregateObjectsMessagesWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""An object allowing Aggregation of %ss on a local Weaviate"""
type AggregateObjectsObj {
  ChatsWeaviate(
    ask: QnATransformersAggregateChatsWeaviateAskInpObj

    """Specify which properties to group by"""
    groupBy: [String]
    hybrid: AggregateObjectsChatsWeaviateHybridInpObj

    """Show the first x results (pagination option)"""
    limit: Int
    nearObject: AggregateObjectsChatsWeaviateNearObjectInpObj
    nearText: AggregateChatsWeaviateNearTextInpObj
    nearVector: AggregateObjectsChatsWeaviateNearVectorInpObj

    """Show the first x results (pagination option)"""
    objectLimit: Int

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: AggregateObjectsChatsWeaviateWhereInpObj
  ): [AggregateChatsWeaviate]
  DocumentsWeaviates(
    ask: QnATransformersAggregateDocumentsWeaviatesAskInpObj

    """Specify which properties to group by"""
    groupBy: [String]
    hybrid: AggregateObjectsDocumentsWeaviatesHybridInpObj

    """Show the first x results (pagination option)"""
    limit: Int
    nearObject: AggregateObjectsDocumentsWeaviatesNearObjectInpObj
    nearText: AggregateDocumentsWeaviatesNearTextInpObj
    nearVector: AggregateObjectsDocumentsWeaviatesNearVectorInpObj

    """Show the first x results (pagination option)"""
    objectLimit: Int

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: AggregateObjectsDocumentsWeaviatesWhereInpObj
  ): [AggregateDocumentsWeaviates]
  MessagesWeaviate(
    ask: QnATransformersAggregateMessagesWeaviateAskInpObj

    """Specify which properties to group by"""
    groupBy: [String]
    hybrid: AggregateObjectsMessagesWeaviateHybridInpObj

    """Show the first x results (pagination option)"""
    limit: Int
    nearObject: AggregateObjectsMessagesWeaviateNearObjectInpObj
    nearText: AggregateMessagesWeaviateNearTextInpObj
    nearVector: AggregateObjectsMessagesWeaviateNearVectorInpObj

    """Show the first x results (pagination option)"""
    objectLimit: Int

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: AggregateObjectsMessagesWeaviateWhereInpObj
  ): [AggregateMessagesWeaviate]
  RolesWeaviate(
    ask: QnATransformersAggregateRolesWeaviateAskInpObj

    """Specify which properties to group by"""
    groupBy: [String]
    hybrid: AggregateObjectsRolesWeaviateHybridInpObj

    """Show the first x results (pagination option)"""
    limit: Int
    nearObject: AggregateObjectsRolesWeaviateNearObjectInpObj
    nearText: AggregateRolesWeaviateNearTextInpObj
    nearVector: AggregateObjectsRolesWeaviateNearVectorInpObj

    """Show the first x results (pagination option)"""
    objectLimit: Int

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: AggregateObjectsRolesWeaviateWhereInpObj
  ): [AggregateRolesWeaviate]
  TemplatesWeaviates(
    ask: QnATransformersAggregateTemplatesWeaviatesAskInpObj

    """Specify which properties to group by"""
    groupBy: [String]
    hybrid: AggregateObjectsTemplatesWeaviatesHybridInpObj

    """Show the first x results (pagination option)"""
    limit: Int
    nearObject: AggregateObjectsTemplatesWeaviatesNearObjectInpObj
    nearText: AggregateTemplatesWeaviatesNearTextInpObj
    nearVector: AggregateObjectsTemplatesWeaviatesNearVectorInpObj

    """Show the first x results (pagination option)"""
    objectLimit: Int

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: AggregateObjectsTemplatesWeaviatesWhereInpObj
  ): [AggregateTemplatesWeaviates]
}

"""Hybrid search"""
input AggregateObjectsRolesWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input AggregateObjectsRolesWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

input AggregateObjectsRolesWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

input AggregateObjectsRolesWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input AggregateObjectsRolesWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input AggregateObjectsRolesWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: AggregateObjectsRolesWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: AggregateObjectsRolesWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateObjectsRolesWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsRolesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsRolesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsRolesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsRolesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsRolesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsRolesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsRolesWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input AggregateObjectsRolesWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsRolesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsRolesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsRolesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsRolesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsRolesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsRolesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsRolesWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum AggregateObjectsRolesWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Hybrid search"""
input AggregateObjectsTemplatesWeaviatesHybridInpObj {
  """Search weight"""
  alpha: Float

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input AggregateObjectsTemplatesWeaviatesNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

input AggregateObjectsTemplatesWeaviatesNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

input AggregateObjectsTemplatesWeaviatesWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input AggregateObjectsTemplatesWeaviatesWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input AggregateObjectsTemplatesWeaviatesWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: AggregateObjectsTemplatesWeaviatesWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: AggregateObjectsTemplatesWeaviatesWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateObjectsTemplatesWeaviatesWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsTemplatesWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsTemplatesWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsTemplatesWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsTemplatesWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsTemplatesWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsTemplatesWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsTemplatesWeaviates
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input AggregateObjectsTemplatesWeaviatesWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [AggregateObjectsTemplatesWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: AggregateObjectsTemplatesWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanAggregateObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateAggregateObjectsTemplatesWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: AggregateObjectsTemplatesWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntAggregateObjectsTemplatesWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatAggregateObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringAggregateObjectsTemplatesWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextAggregateObjectsTemplatesWeaviates
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum AggregateObjectsTemplatesWeaviatesWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

type AggregateRolesWeaviate {
  """Indicates the group of returned data"""
  groupedBy: AggregateRolesWeaviateGroupedByObj

  """
  An object used to Get Meta information about Objects on a local Weaviate
  """
  meta: AggregateRolesWeaviateMetaObject

  """
  Aggregate this property"name"
  """
  name: AggregateRolesWeaviatenameObj

  """
  Aggregate this property"title"
  """
  title: AggregateRolesWeaviatetitleObj
}

"""An object containing the path and value of the grouped property"""
type AggregateRolesWeaviateGroupedByObj {
  """The path of the grouped property"""
  path: [String]

  """The value of the grouped property"""
  value: String
}

type AggregateRolesWeaviateMetaObject {
  count: Int
}

input AggregateRolesWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateRolesWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateRolesWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input AggregateRolesWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateRolesWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateRolesWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

"""An object containing Aggregation information about this property"""
type AggregateRolesWeaviatenameObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateRolesWeaviatenameTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateRolesWeaviatenameTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateRolesWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: AggregateRolesWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: AggregateRolesWeaviateMoveTo
}

"""An object containing Aggregation information about this property"""
type AggregateRolesWeaviatetitleObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateRolesWeaviatetitleTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateRolesWeaviatetitleTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

type AggregateTemplatesWeaviates {
  """
  Aggregate this property"description"
  """
  description: AggregateTemplatesWeaviatesdescriptionObj

  """Indicates the group of returned data"""
  groupedBy: AggregateTemplatesWeaviatesGroupedByObj

  """
  An object used to Get Meta information about Objects on a local Weaviate
  """
  meta: AggregateTemplatesWeaviatesMetaObject

  """
  Aggregate this property"name"
  """
  name: AggregateTemplatesWeaviatesnameObj

  """
  Aggregate this property"title"
  """
  title: AggregateTemplatesWeaviatestitleObj
}

"""An object containing Aggregation information about this property"""
type AggregateTemplatesWeaviatesdescriptionObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateTemplatesWeaviatesdescriptionTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateTemplatesWeaviatesdescriptionTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""An object containing the path and value of the grouped property"""
type AggregateTemplatesWeaviatesGroupedByObj {
  """The path of the grouped property"""
  path: [String]

  """The value of the grouped property"""
  value: String
}

type AggregateTemplatesWeaviatesMetaObject {
  count: Int
}

input AggregateTemplatesWeaviatesMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateTemplatesWeaviatesMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateTemplatesWeaviatesMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input AggregateTemplatesWeaviatesMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [AggregateTemplatesWeaviatesMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input AggregateTemplatesWeaviatesMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

"""An object containing Aggregation information about this property"""
type AggregateTemplatesWeaviatesnameObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateTemplatesWeaviatesnameTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateTemplatesWeaviatesnameTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input AggregateTemplatesWeaviatesNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: AggregateTemplatesWeaviatesMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: AggregateTemplatesWeaviatesMoveTo
}

"""An object containing Aggregation information about this property"""
type AggregateTemplatesWeaviatestitleObj {
  """The total amount of found instances for this property"""
  count: Int

  """
  An object containing data about the most frequently occurring values for this property
  """
  topOccurrences(
    """Show the first x results (pagination option)"""
    limit: Int
  ): [AggregateTemplatesWeaviatestitleTopOccurrencesObj]

  """Aggregate on the total amount of found property values"""
  type: String
}

"""
An object containing data about the most frequently occurring values for this property
"""
type AggregateTemplatesWeaviatestitleTopOccurrencesObj {
  """How often the most frequently occurring value for this property occurs"""
  occurs: Int

  """The most frequently occurring value for this property"""
  value: String
}

"""
columns and relationships of "ai_categories"
"""
type ai_categories {
  icon: String
  id: Int!
  name: String
  title: String!
}

"""
aggregated selection of "ai_categories"
"""
type ai_categories_aggregate {
  aggregate: ai_categories_aggregate_fields
  nodes: [ai_categories!]!
}

"""
aggregate fields of "ai_categories"
"""
type ai_categories_aggregate_fields {
  avg: ai_categories_avg_fields
  count(columns: [ai_categories_select_column!], distinct: Boolean): Int!
  max: ai_categories_max_fields
  min: ai_categories_min_fields
  stddev: ai_categories_stddev_fields
  stddev_pop: ai_categories_stddev_pop_fields
  stddev_samp: ai_categories_stddev_samp_fields
  sum: ai_categories_sum_fields
  var_pop: ai_categories_var_pop_fields
  var_samp: ai_categories_var_samp_fields
  variance: ai_categories_variance_fields
}

"""aggregate avg on columns"""
type ai_categories_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "ai_categories". All fields are combined with a logical 'AND'.
"""
input ai_categories_bool_exp {
  _and: [ai_categories_bool_exp!]
  _not: ai_categories_bool_exp
  _or: [ai_categories_bool_exp!]
  icon: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "ai_categories"
"""
enum ai_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ai_categories_pkey
}

"""
input type for incrementing numeric columns in table "ai_categories"
"""
input ai_categories_inc_input {
  id: Int
}

"""
input type for inserting data into table "ai_categories"
"""
input ai_categories_insert_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate max on columns"""
type ai_categories_max_fields {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate min on columns"""
type ai_categories_min_fields {
  icon: String
  id: Int
  name: String
  title: String
}

"""
response of any mutation on the table "ai_categories"
"""
type ai_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ai_categories!]!
}

"""
on_conflict condition type for table "ai_categories"
"""
input ai_categories_on_conflict {
  constraint: ai_categories_constraint!
  update_columns: [ai_categories_update_column!]! = []
  where: ai_categories_bool_exp
}

"""Ordering options when selecting data from "ai_categories"."""
input ai_categories_order_by {
  icon: order_by
  id: order_by
  name: order_by
  title: order_by
}

"""primary key columns input for table: ai_categories"""
input ai_categories_pk_columns_input {
  id: Int!
}

"""
select columns of table "ai_categories"
"""
enum ai_categories_select_column {
  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

"""
input type for updating data in table "ai_categories"
"""
input ai_categories_set_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate stddev on columns"""
type ai_categories_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type ai_categories_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type ai_categories_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "ai_categories"
"""
input ai_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ai_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ai_categories_stream_cursor_value_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate sum on columns"""
type ai_categories_sum_fields {
  id: Int
}

"""
update columns of table "ai_categories"
"""
enum ai_categories_update_column {
  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

input ai_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ai_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ai_categories_set_input

  """filter the rows which have to be updated"""
  where: ai_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type ai_categories_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type ai_categories_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type ai_categories_variance_fields {
  id: Float
}

"""
columns and relationships of "ai_models"
"""
type ai_models {
  id: uuid!
  level: Int
  name: String!
}

"""
aggregated selection of "ai_models"
"""
type ai_models_aggregate {
  aggregate: ai_models_aggregate_fields
  nodes: [ai_models!]!
}

"""
aggregate fields of "ai_models"
"""
type ai_models_aggregate_fields {
  avg: ai_models_avg_fields
  count(columns: [ai_models_select_column!], distinct: Boolean): Int!
  max: ai_models_max_fields
  min: ai_models_min_fields
  stddev: ai_models_stddev_fields
  stddev_pop: ai_models_stddev_pop_fields
  stddev_samp: ai_models_stddev_samp_fields
  sum: ai_models_sum_fields
  var_pop: ai_models_var_pop_fields
  var_samp: ai_models_var_samp_fields
  variance: ai_models_variance_fields
}

"""aggregate avg on columns"""
type ai_models_avg_fields {
  level: Float
}

"""
Boolean expression to filter rows from the table "ai_models". All fields are combined with a logical 'AND'.
"""
input ai_models_bool_exp {
  _and: [ai_models_bool_exp!]
  _not: ai_models_bool_exp
  _or: [ai_models_bool_exp!]
  id: uuid_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "ai_models"
"""
enum ai_models_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ai_models_pkey
}

"""
input type for incrementing numeric columns in table "ai_models"
"""
input ai_models_inc_input {
  level: Int
}

"""
input type for inserting data into table "ai_models"
"""
input ai_models_insert_input {
  id: uuid
  level: Int
  name: String
}

"""aggregate max on columns"""
type ai_models_max_fields {
  id: uuid
  level: Int
  name: String
}

"""aggregate min on columns"""
type ai_models_min_fields {
  id: uuid
  level: Int
  name: String
}

"""
response of any mutation on the table "ai_models"
"""
type ai_models_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ai_models!]!
}

"""
on_conflict condition type for table "ai_models"
"""
input ai_models_on_conflict {
  constraint: ai_models_constraint!
  update_columns: [ai_models_update_column!]! = []
  where: ai_models_bool_exp
}

"""Ordering options when selecting data from "ai_models"."""
input ai_models_order_by {
  id: order_by
  level: order_by
  name: order_by
}

"""primary key columns input for table: ai_models"""
input ai_models_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ai_models"
"""
enum ai_models_select_column {
  """column name"""
  id

  """column name"""
  level

  """column name"""
  name
}

"""
input type for updating data in table "ai_models"
"""
input ai_models_set_input {
  id: uuid
  level: Int
  name: String
}

"""aggregate stddev on columns"""
type ai_models_stddev_fields {
  level: Float
}

"""aggregate stddev_pop on columns"""
type ai_models_stddev_pop_fields {
  level: Float
}

"""aggregate stddev_samp on columns"""
type ai_models_stddev_samp_fields {
  level: Float
}

"""
Streaming cursor of the table "ai_models"
"""
input ai_models_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ai_models_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ai_models_stream_cursor_value_input {
  id: uuid
  level: Int
  name: String
}

"""aggregate sum on columns"""
type ai_models_sum_fields {
  level: Int
}

"""
update columns of table "ai_models"
"""
enum ai_models_update_column {
  """column name"""
  id

  """column name"""
  level

  """column name"""
  name
}

input ai_models_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ai_models_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ai_models_set_input

  """filter the rows which have to be updated"""
  where: ai_models_bool_exp!
}

"""aggregate var_pop on columns"""
type ai_models_var_pop_fields {
  level: Float
}

"""aggregate var_samp on columns"""
type ai_models_var_samp_fields {
  level: Float
}

"""aggregate variance on columns"""
type ai_models_variance_fields {
  level: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Boolean or Boolean[]"""
scalar BooleanAggregateObjectsChatsWeaviate

"""Boolean or Boolean[]"""
scalar BooleanAggregateObjectsDocumentsWeaviates

"""Boolean or Boolean[]"""
scalar BooleanAggregateObjectsMessagesWeaviate

"""Boolean or Boolean[]"""
scalar BooleanAggregateObjectsRolesWeaviate

"""Boolean or Boolean[]"""
scalar BooleanAggregateObjectsTemplatesWeaviates

"""Boolean or Boolean[]"""
scalar BooleanGetObjectsChatsWeaviate

"""Boolean or Boolean[]"""
scalar BooleanGetObjectsDocumentsWeaviates

"""Boolean or Boolean[]"""
scalar BooleanGetObjectsMessagesWeaviate

"""Boolean or Boolean[]"""
scalar BooleanGetObjectsRolesWeaviate

"""Boolean or Boolean[]"""
scalar BooleanGetObjectsTemplatesWeaviates

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "chats"
"""
type chats {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  model: String
  system_promt: String
  title: String

  """An object relationship"""
  user: users
  userId: uuid
}

"""
aggregated selection of "chats"
"""
type chats_aggregate {
  aggregate: chats_aggregate_fields
  nodes: [chats!]!
}

input chats_aggregate_bool_exp {
  count: chats_aggregate_bool_exp_count
}

input chats_aggregate_bool_exp_count {
  arguments: [chats_select_column!]
  distinct: Boolean
  filter: chats_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "chats"
"""
type chats_aggregate_fields {
  count(columns: [chats_select_column!], distinct: Boolean): Int!
  max: chats_max_fields
  min: chats_min_fields
}

"""
order by aggregate values of table "chats"
"""
input chats_aggregate_order_by {
  count: order_by
  max: chats_max_order_by
  min: chats_min_order_by
}

"""
input type for inserting array relation for remote table "chats"
"""
input chats_arr_rel_insert_input {
  data: [chats_insert_input!]!

  """upsert condition"""
  on_conflict: chats_on_conflict
}

"""
Boolean expression to filter rows from the table "chats". All fields are combined with a logical 'AND'.
"""
input chats_bool_exp {
  _and: [chats_bool_exp!]
  _not: chats_bool_exp
  _or: [chats_bool_exp!]
  createdAt: timestamp_comparison_exp
  description: String_comparison_exp
  icon: uuid_comparison_exp
  id: uuid_comparison_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  model: String_comparison_exp
  system_promt: String_comparison_exp
  title: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "chats"
"""
enum chats_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  chats_pkey

  """
  unique or primary key constraint on columns "id"
  """
  chats_uid_key
}

"""
input type for inserting data into table "chats"
"""
input chats_insert_input {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid
  messages: messages_arr_rel_insert_input
  model: String
  system_promt: String
  title: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type chats_max_fields {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid
  model: String
  system_promt: String
  title: String
  userId: uuid
}

"""
order by max() on columns of table "chats"
"""
input chats_max_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  model: order_by
  system_promt: order_by
  title: order_by
  userId: order_by
}

"""aggregate min on columns"""
type chats_min_fields {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid
  model: String
  system_promt: String
  title: String
  userId: uuid
}

"""
order by min() on columns of table "chats"
"""
input chats_min_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  model: order_by
  system_promt: order_by
  title: order_by
  userId: order_by
}

"""
response of any mutation on the table "chats"
"""
type chats_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chats!]!
}

"""
input type for inserting object relation for remote table "chats"
"""
input chats_obj_rel_insert_input {
  data: chats_insert_input!

  """upsert condition"""
  on_conflict: chats_on_conflict
}

"""
on_conflict condition type for table "chats"
"""
input chats_on_conflict {
  constraint: chats_constraint!
  update_columns: [chats_update_column!]! = []
  where: chats_bool_exp
}

"""Ordering options when selecting data from "chats"."""
input chats_order_by {
  createdAt: order_by
  description: order_by
  icon: order_by
  id: order_by
  messages_aggregate: messages_aggregate_order_by
  model: order_by
  system_promt: order_by
  title: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: chats"""
input chats_pk_columns_input {
  id: uuid!
}

"""
select columns of table "chats"
"""
enum chats_select_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  model

  """column name"""
  system_promt

  """column name"""
  title

  """column name"""
  userId
}

"""
input type for updating data in table "chats"
"""
input chats_set_input {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid
  model: String
  system_promt: String
  title: String
  userId: uuid
}

"""
Streaming cursor of the table "chats"
"""
input chats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chats_stream_cursor_value_input {
  createdAt: timestamp
  description: String
  icon: uuid
  id: uuid
  model: String
  system_promt: String
  title: String
  userId: uuid
}

"""
update columns of table "chats"
"""
enum chats_update_column {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  model

  """column name"""
  system_promt

  """column name"""
  title

  """column name"""
  userId
}

input chats_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: chats_set_input

  """filter the rows which have to be updated"""
  where: chats_bool_exp!
}

type ChatsWeaviate {
  _additional: ChatsWeaviateAdditional
  createdAt: String
  title: String
  userId: String
}

type ChatsWeaviateAdditional {
  answer: ChatsWeaviateAdditionalAnswer
  certainty: Float
  classification: ChatsWeaviateAdditionalClassification
  creationTimeUnix: String
  distance: Float
  explainScore: String
  featureProjection(algorithm: String, dimensions: Int, iterations: Int, learningRate: Int, perplexity: Int): ChatsWeaviateAdditionalFeatureProjection
  group: ChatsWeaviateAdditionalGroup

  """The UUID of a Object, assigned by its local Weaviate"""
  id: String
  lastUpdateTimeUnix: String
  rerank(
    """Property to rank from"""
    property: String

    """Properties which contains text"""
    query: String
  ): [ChatsWeaviateAdditionalReranker]
  score: String
  vector: [Float]
}

type ChatsWeaviateAdditionalAnswer {
  endPosition: Int
  hasAnswer: Boolean
  property: String
  result: String
  startPosition: Int
}

type ChatsWeaviateAdditionalClassification {
  basedOn: [String]
  classifiedFields: [String]
  completed: String
  id: String
  scope: [String]
}

type ChatsWeaviateAdditionalFeatureProjection {
  vector: [Float]
}

type ChatsWeaviateAdditionalGroup {
  count: Int
  groupedBy: ChatsWeaviateAdditionalGroupGroupedBy
  hits: [ChatsWeaviateAdditionalGroupHits]
  id: Int
  maxDistance: Float
  minDistance: Float
}

type ChatsWeaviateAdditionalGroupGroupedBy {
  path: [String]
  value: String
}

type ChatsWeaviateAdditionalGroupHits {
  _additional: ChatsWeaviateAdditionalGroupHitsAdditional
  createdAt: String
  title: String
  userId: String
}

type ChatsWeaviateAdditionalGroupHitsAdditional {
  distance: Float
  id: String
  vector: [Float]
}

type ChatsWeaviateAdditionalReranker {
  score: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "directus_files"
"""
type directus_files {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String!
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid!
  location: String
  metadata(
    """JSON select path"""
    path: String
  ): json
  modified_by: uuid
  modified_on: timestamptz!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!
  storage: String!
  tags: String

  """An array relationship"""
  templates(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): [templates!]!

  """An aggregate relationship"""
  templates_aggregate(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): templates_aggregate!
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz!
  width: Int
}

"""
aggregated selection of "directus_files"
"""
type directus_files_aggregate {
  aggregate: directus_files_aggregate_fields
  nodes: [directus_files!]!
}

"""
aggregate fields of "directus_files"
"""
type directus_files_aggregate_fields {
  avg: directus_files_avg_fields
  count(columns: [directus_files_select_column!], distinct: Boolean): Int!
  max: directus_files_max_fields
  min: directus_files_min_fields
  stddev: directus_files_stddev_fields
  stddev_pop: directus_files_stddev_pop_fields
  stddev_samp: directus_files_stddev_samp_fields
  sum: directus_files_sum_fields
  var_pop: directus_files_var_pop_fields
  var_samp: directus_files_var_samp_fields
  variance: directus_files_variance_fields
}

"""aggregate avg on columns"""
type directus_files_avg_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""
Boolean expression to filter rows from the table "directus_files". All fields are combined with a logical 'AND'.
"""
input directus_files_bool_exp {
  _and: [directus_files_bool_exp!]
  _not: directus_files_bool_exp
  _or: [directus_files_bool_exp!]
  charset: String_comparison_exp
  description: String_comparison_exp
  duration: Int_comparison_exp
  embed: String_comparison_exp
  filename_disk: String_comparison_exp
  filename_download: String_comparison_exp
  filesize: bigint_comparison_exp
  folder: uuid_comparison_exp
  height: Int_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  metadata: json_comparison_exp
  modified_by: uuid_comparison_exp
  modified_on: timestamptz_comparison_exp
  roles: roles_bool_exp
  roles_aggregate: roles_aggregate_bool_exp
  storage: String_comparison_exp
  tags: String_comparison_exp
  templates: templates_bool_exp
  templates_aggregate: templates_aggregate_bool_exp
  title: String_comparison_exp
  type: String_comparison_exp
  uploaded_by: uuid_comparison_exp
  uploaded_on: timestamptz_comparison_exp
  width: Int_comparison_exp
}

"""
unique or primary key constraints on table "directus_files"
"""
enum directus_files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  directus_files_pkey
}

"""
input type for incrementing numeric columns in table "directus_files"
"""
input directus_files_inc_input {
  duration: Int
  filesize: bigint
  height: Int
  width: Int
}

"""
input type for inserting data into table "directus_files"
"""
input directus_files_insert_input {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid
  location: String
  metadata: json
  modified_by: uuid
  modified_on: timestamptz
  roles: roles_arr_rel_insert_input
  storage: String
  tags: String
  templates: templates_arr_rel_insert_input
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz
  width: Int
}

"""aggregate max on columns"""
type directus_files_max_fields {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid
  location: String
  modified_by: uuid
  modified_on: timestamptz
  storage: String
  tags: String
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz
  width: Int
}

"""aggregate min on columns"""
type directus_files_min_fields {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid
  location: String
  modified_by: uuid
  modified_on: timestamptz
  storage: String
  tags: String
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz
  width: Int
}

"""
response of any mutation on the table "directus_files"
"""
type directus_files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [directus_files!]!
}

"""
input type for inserting object relation for remote table "directus_files"
"""
input directus_files_obj_rel_insert_input {
  data: directus_files_insert_input!

  """upsert condition"""
  on_conflict: directus_files_on_conflict
}

"""
on_conflict condition type for table "directus_files"
"""
input directus_files_on_conflict {
  constraint: directus_files_constraint!
  update_columns: [directus_files_update_column!]! = []
  where: directus_files_bool_exp
}

"""Ordering options when selecting data from "directus_files"."""
input directus_files_order_by {
  charset: order_by
  description: order_by
  duration: order_by
  embed: order_by
  filename_disk: order_by
  filename_download: order_by
  filesize: order_by
  folder: order_by
  height: order_by
  id: order_by
  location: order_by
  metadata: order_by
  modified_by: order_by
  modified_on: order_by
  roles_aggregate: roles_aggregate_order_by
  storage: order_by
  tags: order_by
  templates_aggregate: templates_aggregate_order_by
  title: order_by
  type: order_by
  uploaded_by: order_by
  uploaded_on: order_by
  width: order_by
}

"""primary key columns input for table: directus_files"""
input directus_files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "directus_files"
"""
enum directus_files_select_column {
  """column name"""
  charset

  """column name"""
  description

  """column name"""
  duration

  """column name"""
  embed

  """column name"""
  filename_disk

  """column name"""
  filename_download

  """column name"""
  filesize

  """column name"""
  folder

  """column name"""
  height

  """column name"""
  id

  """column name"""
  location

  """column name"""
  metadata

  """column name"""
  modified_by

  """column name"""
  modified_on

  """column name"""
  storage

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  type

  """column name"""
  uploaded_by

  """column name"""
  uploaded_on

  """column name"""
  width
}

"""
input type for updating data in table "directus_files"
"""
input directus_files_set_input {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid
  location: String
  metadata: json
  modified_by: uuid
  modified_on: timestamptz
  storage: String
  tags: String
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz
  width: Int
}

"""aggregate stddev on columns"""
type directus_files_stddev_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""aggregate stddev_pop on columns"""
type directus_files_stddev_pop_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""aggregate stddev_samp on columns"""
type directus_files_stddev_samp_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""
Streaming cursor of the table "directus_files"
"""
input directus_files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: directus_files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input directus_files_stream_cursor_value_input {
  charset: String
  description: String
  duration: Int
  embed: String
  filename_disk: String
  filename_download: String
  filesize: bigint
  folder: uuid
  height: Int
  id: uuid
  location: String
  metadata: json
  modified_by: uuid
  modified_on: timestamptz
  storage: String
  tags: String
  title: String
  type: String
  uploaded_by: uuid
  uploaded_on: timestamptz
  width: Int
}

"""aggregate sum on columns"""
type directus_files_sum_fields {
  duration: Int
  filesize: bigint
  height: Int
  width: Int
}

"""
update columns of table "directus_files"
"""
enum directus_files_update_column {
  """column name"""
  charset

  """column name"""
  description

  """column name"""
  duration

  """column name"""
  embed

  """column name"""
  filename_disk

  """column name"""
  filename_download

  """column name"""
  filesize

  """column name"""
  folder

  """column name"""
  height

  """column name"""
  id

  """column name"""
  location

  """column name"""
  metadata

  """column name"""
  modified_by

  """column name"""
  modified_on

  """column name"""
  storage

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  type

  """column name"""
  uploaded_by

  """column name"""
  uploaded_on

  """column name"""
  width
}

input directus_files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: directus_files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: directus_files_set_input

  """filter the rows which have to be updated"""
  where: directus_files_bool_exp!
}

"""aggregate var_pop on columns"""
type directus_files_var_pop_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""aggregate var_samp on columns"""
type directus_files_var_samp_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""aggregate variance on columns"""
type directus_files_variance_fields {
  duration: Float
  filesize: Float
  height: Float
  width: Float
}

"""
columns and relationships of "directus_users"
"""
type directus_users {
  appearance: String
  auth_data(
    """JSON select path"""
    path: String
  ): json
  avatar: uuid
  description: String
  email: String
  email_notifications: Boolean
  external_identifier: String
  first_name: String
  id: uuid!
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String!
  role: uuid
  status: String!
  tags(
    """JSON select path"""
    path: String
  ): json
  tfa_secret: String
  theme_dark: String
  theme_dark_overrides(
    """JSON select path"""
    path: String
  ): json
  theme_light: String
  theme_light_overrides(
    """JSON select path"""
    path: String
  ): json
  title: String
  token: String
}

"""
aggregated selection of "directus_users"
"""
type directus_users_aggregate {
  aggregate: directus_users_aggregate_fields
  nodes: [directus_users!]!
}

"""
aggregate fields of "directus_users"
"""
type directus_users_aggregate_fields {
  count(columns: [directus_users_select_column!], distinct: Boolean): Int!
  max: directus_users_max_fields
  min: directus_users_min_fields
}

"""
Boolean expression to filter rows from the table "directus_users". All fields are combined with a logical 'AND'.
"""
input directus_users_bool_exp {
  _and: [directus_users_bool_exp!]
  _not: directus_users_bool_exp
  _or: [directus_users_bool_exp!]
  appearance: String_comparison_exp
  auth_data: json_comparison_exp
  avatar: uuid_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  email_notifications: Boolean_comparison_exp
  external_identifier: String_comparison_exp
  first_name: String_comparison_exp
  id: uuid_comparison_exp
  language: String_comparison_exp
  last_access: timestamptz_comparison_exp
  last_name: String_comparison_exp
  last_page: String_comparison_exp
  location: String_comparison_exp
  password: String_comparison_exp
  provider: String_comparison_exp
  role: uuid_comparison_exp
  status: String_comparison_exp
  tags: json_comparison_exp
  tfa_secret: String_comparison_exp
  theme_dark: String_comparison_exp
  theme_dark_overrides: json_comparison_exp
  theme_light: String_comparison_exp
  theme_light_overrides: json_comparison_exp
  title: String_comparison_exp
  token: String_comparison_exp
}

"""
unique or primary key constraints on table "directus_users"
"""
enum directus_users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  directus_users_email_unique

  """
  unique or primary key constraint on columns "external_identifier"
  """
  directus_users_external_identifier_unique

  """
  unique or primary key constraint on columns "id"
  """
  directus_users_pkey

  """
  unique or primary key constraint on columns "token"
  """
  directus_users_token_unique
}

"""
input type for inserting data into table "directus_users"
"""
input directus_users_insert_input {
  appearance: String
  auth_data: json
  avatar: uuid
  description: String
  email: String
  email_notifications: Boolean
  external_identifier: String
  first_name: String
  id: uuid
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String
  role: uuid
  status: String
  tags: json
  tfa_secret: String
  theme_dark: String
  theme_dark_overrides: json
  theme_light: String
  theme_light_overrides: json
  title: String
  token: String
}

"""aggregate max on columns"""
type directus_users_max_fields {
  appearance: String
  avatar: uuid
  description: String
  email: String
  external_identifier: String
  first_name: String
  id: uuid
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String
  role: uuid
  status: String
  tfa_secret: String
  theme_dark: String
  theme_light: String
  title: String
  token: String
}

"""aggregate min on columns"""
type directus_users_min_fields {
  appearance: String
  avatar: uuid
  description: String
  email: String
  external_identifier: String
  first_name: String
  id: uuid
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String
  role: uuid
  status: String
  tfa_secret: String
  theme_dark: String
  theme_light: String
  title: String
  token: String
}

"""
response of any mutation on the table "directus_users"
"""
type directus_users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [directus_users!]!
}

"""
on_conflict condition type for table "directus_users"
"""
input directus_users_on_conflict {
  constraint: directus_users_constraint!
  update_columns: [directus_users_update_column!]! = []
  where: directus_users_bool_exp
}

"""Ordering options when selecting data from "directus_users"."""
input directus_users_order_by {
  appearance: order_by
  auth_data: order_by
  avatar: order_by
  description: order_by
  email: order_by
  email_notifications: order_by
  external_identifier: order_by
  first_name: order_by
  id: order_by
  language: order_by
  last_access: order_by
  last_name: order_by
  last_page: order_by
  location: order_by
  password: order_by
  provider: order_by
  role: order_by
  status: order_by
  tags: order_by
  tfa_secret: order_by
  theme_dark: order_by
  theme_dark_overrides: order_by
  theme_light: order_by
  theme_light_overrides: order_by
  title: order_by
  token: order_by
}

"""primary key columns input for table: directus_users"""
input directus_users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "directus_users"
"""
enum directus_users_select_column {
  """column name"""
  appearance

  """column name"""
  auth_data

  """column name"""
  avatar

  """column name"""
  description

  """column name"""
  email

  """column name"""
  email_notifications

  """column name"""
  external_identifier

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  language

  """column name"""
  last_access

  """column name"""
  last_name

  """column name"""
  last_page

  """column name"""
  location

  """column name"""
  password

  """column name"""
  provider

  """column name"""
  role

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  tfa_secret

  """column name"""
  theme_dark

  """column name"""
  theme_dark_overrides

  """column name"""
  theme_light

  """column name"""
  theme_light_overrides

  """column name"""
  title

  """column name"""
  token
}

"""
input type for updating data in table "directus_users"
"""
input directus_users_set_input {
  appearance: String
  auth_data: json
  avatar: uuid
  description: String
  email: String
  email_notifications: Boolean
  external_identifier: String
  first_name: String
  id: uuid
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String
  role: uuid
  status: String
  tags: json
  tfa_secret: String
  theme_dark: String
  theme_dark_overrides: json
  theme_light: String
  theme_light_overrides: json
  title: String
  token: String
}

"""
Streaming cursor of the table "directus_users"
"""
input directus_users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: directus_users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input directus_users_stream_cursor_value_input {
  appearance: String
  auth_data: json
  avatar: uuid
  description: String
  email: String
  email_notifications: Boolean
  external_identifier: String
  first_name: String
  id: uuid
  language: String
  last_access: timestamptz
  last_name: String
  last_page: String
  location: String
  password: String
  provider: String
  role: uuid
  status: String
  tags: json
  tfa_secret: String
  theme_dark: String
  theme_dark_overrides: json
  theme_light: String
  theme_light_overrides: json
  title: String
  token: String
}

"""
update columns of table "directus_users"
"""
enum directus_users_update_column {
  """column name"""
  appearance

  """column name"""
  auth_data

  """column name"""
  avatar

  """column name"""
  description

  """column name"""
  email

  """column name"""
  email_notifications

  """column name"""
  external_identifier

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  language

  """column name"""
  last_access

  """column name"""
  last_name

  """column name"""
  last_page

  """column name"""
  location

  """column name"""
  password

  """column name"""
  provider

  """column name"""
  role

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  tfa_secret

  """column name"""
  theme_dark

  """column name"""
  theme_dark_overrides

  """column name"""
  theme_light

  """column name"""
  theme_light_overrides

  """column name"""
  title

  """column name"""
  token
}

input directus_users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: directus_users_set_input

  """filter the rows which have to be updated"""
  where: directus_users_bool_exp!
}

"""
columns and relationships of "documents"
"""
type documents {
  blocks(
    """JSON select path"""
    path: String
  ): json
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid!
  name: String!
  time: bigint

  """An object relationship"""
  user: users
  userId: uuid
}

"""
aggregated selection of "documents"
"""
type documents_aggregate {
  aggregate: documents_aggregate_fields
  nodes: [documents!]!
}

input documents_aggregate_bool_exp {
  count: documents_aggregate_bool_exp_count
}

input documents_aggregate_bool_exp_count {
  arguments: [documents_select_column!]
  distinct: Boolean
  filter: documents_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "documents"
"""
type documents_aggregate_fields {
  avg: documents_avg_fields
  count(columns: [documents_select_column!], distinct: Boolean): Int!
  max: documents_max_fields
  min: documents_min_fields
  stddev: documents_stddev_fields
  stddev_pop: documents_stddev_pop_fields
  stddev_samp: documents_stddev_samp_fields
  sum: documents_sum_fields
  var_pop: documents_var_pop_fields
  var_samp: documents_var_samp_fields
  variance: documents_variance_fields
}

"""
order by aggregate values of table "documents"
"""
input documents_aggregate_order_by {
  avg: documents_avg_order_by
  count: order_by
  max: documents_max_order_by
  min: documents_min_order_by
  stddev: documents_stddev_order_by
  stddev_pop: documents_stddev_pop_order_by
  stddev_samp: documents_stddev_samp_order_by
  sum: documents_sum_order_by
  var_pop: documents_var_pop_order_by
  var_samp: documents_var_samp_order_by
  variance: documents_variance_order_by
}

"""
input type for inserting array relation for remote table "documents"
"""
input documents_arr_rel_insert_input {
  data: [documents_insert_input!]!

  """upsert condition"""
  on_conflict: documents_on_conflict
}

"""aggregate avg on columns"""
type documents_avg_fields {
  time: Float
}

"""
order by avg() on columns of table "documents"
"""
input documents_avg_order_by {
  time: order_by
}

"""
Boolean expression to filter rows from the table "documents". All fields are combined with a logical 'AND'.
"""
input documents_bool_exp {
  _and: [documents_bool_exp!]
  _not: documents_bool_exp
  _or: [documents_bool_exp!]
  blocks: json_comparison_exp
  date_created: timestamptz_comparison_exp
  date_updated: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  time: bigint_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "documents"
"""
enum documents_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  documents_pkey
}

"""
input type for incrementing numeric columns in table "documents"
"""
input documents_inc_input {
  time: bigint
}

"""
input type for inserting data into table "documents"
"""
input documents_insert_input {
  blocks: json
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid
  name: String
  time: bigint
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type documents_max_fields {
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid
  name: String
  time: bigint
  userId: uuid
}

"""
order by max() on columns of table "documents"
"""
input documents_max_order_by {
  date_created: order_by
  date_updated: order_by
  id: order_by
  name: order_by
  time: order_by
  userId: order_by
}

"""aggregate min on columns"""
type documents_min_fields {
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid
  name: String
  time: bigint
  userId: uuid
}

"""
order by min() on columns of table "documents"
"""
input documents_min_order_by {
  date_created: order_by
  date_updated: order_by
  id: order_by
  name: order_by
  time: order_by
  userId: order_by
}

"""
response of any mutation on the table "documents"
"""
type documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [documents!]!
}

"""
on_conflict condition type for table "documents"
"""
input documents_on_conflict {
  constraint: documents_constraint!
  update_columns: [documents_update_column!]! = []
  where: documents_bool_exp
}

"""Ordering options when selecting data from "documents"."""
input documents_order_by {
  blocks: order_by
  date_created: order_by
  date_updated: order_by
  id: order_by
  name: order_by
  time: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: documents"""
input documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "documents"
"""
enum documents_select_column {
  """column name"""
  blocks

  """column name"""
  date_created

  """column name"""
  date_updated

  """column name"""
  id

  """column name"""
  name

  """column name"""
  time

  """column name"""
  userId
}

"""
input type for updating data in table "documents"
"""
input documents_set_input {
  blocks: json
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid
  name: String
  time: bigint
  userId: uuid
}

"""aggregate stddev on columns"""
type documents_stddev_fields {
  time: Float
}

"""
order by stddev() on columns of table "documents"
"""
input documents_stddev_order_by {
  time: order_by
}

"""aggregate stddev_pop on columns"""
type documents_stddev_pop_fields {
  time: Float
}

"""
order by stddev_pop() on columns of table "documents"
"""
input documents_stddev_pop_order_by {
  time: order_by
}

"""aggregate stddev_samp on columns"""
type documents_stddev_samp_fields {
  time: Float
}

"""
order by stddev_samp() on columns of table "documents"
"""
input documents_stddev_samp_order_by {
  time: order_by
}

"""
Streaming cursor of the table "documents"
"""
input documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input documents_stream_cursor_value_input {
  blocks: json
  date_created: timestamptz
  date_updated: timestamptz
  id: uuid
  name: String
  time: bigint
  userId: uuid
}

"""aggregate sum on columns"""
type documents_sum_fields {
  time: bigint
}

"""
order by sum() on columns of table "documents"
"""
input documents_sum_order_by {
  time: order_by
}

"""
update columns of table "documents"
"""
enum documents_update_column {
  """column name"""
  blocks

  """column name"""
  date_created

  """column name"""
  date_updated

  """column name"""
  id

  """column name"""
  name

  """column name"""
  time

  """column name"""
  userId
}

input documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: documents_set_input

  """filter the rows which have to be updated"""
  where: documents_bool_exp!
}

"""aggregate var_pop on columns"""
type documents_var_pop_fields {
  time: Float
}

"""
order by var_pop() on columns of table "documents"
"""
input documents_var_pop_order_by {
  time: order_by
}

"""aggregate var_samp on columns"""
type documents_var_samp_fields {
  time: Float
}

"""
order by var_samp() on columns of table "documents"
"""
input documents_var_samp_order_by {
  time: order_by
}

"""aggregate variance on columns"""
type documents_variance_fields {
  time: Float
}

"""
order by variance() on columns of table "documents"
"""
input documents_variance_order_by {
  time: order_by
}

type DocumentsWeaviates {
  _additional: DocumentsWeaviatesAdditional
  name: String
  userId: String
}

type DocumentsWeaviatesAdditional {
  answer: DocumentsWeaviatesAdditionalAnswer
  certainty: Float
  classification: DocumentsWeaviatesAdditionalClassification
  creationTimeUnix: String
  distance: Float
  explainScore: String
  featureProjection(algorithm: String, dimensions: Int, iterations: Int, learningRate: Int, perplexity: Int): DocumentsWeaviatesAdditionalFeatureProjection
  group: DocumentsWeaviatesAdditionalGroup

  """The UUID of a Object, assigned by its local Weaviate"""
  id: String
  lastUpdateTimeUnix: String
  rerank(
    """Property to rank from"""
    property: String

    """Properties which contains text"""
    query: String
  ): [DocumentsWeaviatesAdditionalReranker]
  score: String
  vector: [Float]
}

type DocumentsWeaviatesAdditionalAnswer {
  endPosition: Int
  hasAnswer: Boolean
  property: String
  result: String
  startPosition: Int
}

type DocumentsWeaviatesAdditionalClassification {
  basedOn: [String]
  classifiedFields: [String]
  completed: String
  id: String
  scope: [String]
}

type DocumentsWeaviatesAdditionalFeatureProjection {
  vector: [Float]
}

type DocumentsWeaviatesAdditionalGroup {
  count: Int
  groupedBy: DocumentsWeaviatesAdditionalGroupGroupedBy
  hits: [DocumentsWeaviatesAdditionalGroupHits]
  id: Int
  maxDistance: Float
  minDistance: Float
}

type DocumentsWeaviatesAdditionalGroupGroupedBy {
  path: [String]
  value: String
}

type DocumentsWeaviatesAdditionalGroupHits {
  _additional: DocumentsWeaviatesAdditionalGroupHitsAdditional
  name: String
  userId: String
}

type DocumentsWeaviatesAdditionalGroupHitsAdditional {
  distance: Float
  id: String
  vector: [Float]
}

type DocumentsWeaviatesAdditionalReranker {
  score: Float
}

"""Float or Float[]"""
scalar FloatAggregateObjectsChatsWeaviate

"""Float or Float[]"""
scalar FloatAggregateObjectsDocumentsWeaviates

"""Float or Float[]"""
scalar FloatAggregateObjectsMessagesWeaviate

"""Float or Float[]"""
scalar FloatAggregateObjectsRolesWeaviate

"""Float or Float[]"""
scalar FloatAggregateObjectsTemplatesWeaviates

"""Float or Float[]"""
scalar FloatGetObjectsChatsWeaviate

"""Float or Float[]"""
scalar FloatGetObjectsDocumentsWeaviates

"""Float or Float[]"""
scalar FloatGetObjectsMessagesWeaviate

"""Float or Float[]"""
scalar FloatGetObjectsRolesWeaviate

"""Float or Float[]"""
scalar FloatGetObjectsTemplatesWeaviates

enum FusionEnum {
  rankedFusion
  relativeScoreFusion
}

"""Specify the property of the class to group by"""
input GetObjectsChatsWeaviateGroupByInpObj {
  """Specify the number of groups to be created"""
  groups: Int!

  """Specify the number of max objects in group"""
  objectsPerGroup: Int!

  """
  Specify the path from the objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsChatsWeaviateGroupInpObj {
  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!
  type: GetObjectsChatsWeaviateGroupInpObjTypeEnum
}

enum GetObjectsChatsWeaviateGroupInpObjTypeEnum {
  closest
  merge
}

input GetObjectsChatsWeaviateHybridGetBm25InpObj {
  """The properties to search in"""
  properties: [String]

  """The query to search for"""
  query: String
}

"""Hybrid search"""
input GetObjectsChatsWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Algorithm used for fusing results from vector and keyword search"""
  fusionType: FusionEnum

  """Which properties should be included in the sparse search"""
  properties: [String]

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input GetObjectsChatsWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsChatsWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsChatsWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsChatsWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsChatsWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsChatsWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsChatsWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsChatsWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: GetObjectsChatsWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: GetObjectsChatsWeaviateMoveTo
}

input GetObjectsChatsWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsChatsWeaviateSortInpObj {
  """
  Specify the sort order, either ascending (asc) which is default or descending (desc)
  """
  order: GetObjectsChatsWeaviateSortInpObjTypeEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Get',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]
}

enum GetObjectsChatsWeaviateSortInpObjTypeEnum {
  asc
  desc
}

input GetObjectsChatsWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input GetObjectsChatsWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input GetObjectsChatsWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: GetObjectsChatsWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: GetObjectsChatsWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsChatsWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsChatsWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsChatsWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsChatsWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsChatsWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsChatsWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsChatsWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsChatsWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input GetObjectsChatsWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsChatsWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsChatsWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsChatsWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsChatsWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsChatsWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsChatsWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsChatsWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsChatsWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum GetObjectsChatsWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Specify the property of the class to group by"""
input GetObjectsDocumentsWeaviatesGroupByInpObj {
  """Specify the number of groups to be created"""
  groups: Int!

  """Specify the number of max objects in group"""
  objectsPerGroup: Int!

  """
  Specify the path from the objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsDocumentsWeaviatesGroupInpObj {
  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!
  type: GetObjectsDocumentsWeaviatesGroupInpObjTypeEnum
}

enum GetObjectsDocumentsWeaviatesGroupInpObjTypeEnum {
  closest
  merge
}

input GetObjectsDocumentsWeaviatesHybridGetBm25InpObj {
  """The properties to search in"""
  properties: [String]

  """The query to search for"""
  query: String
}

"""Hybrid search"""
input GetObjectsDocumentsWeaviatesHybridInpObj {
  """Search weight"""
  alpha: Float

  """Algorithm used for fusing results from vector and keyword search"""
  fusionType: FusionEnum

  """Which properties should be included in the sparse search"""
  properties: [String]

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input GetObjectsDocumentsWeaviatesMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsDocumentsWeaviatesMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsDocumentsWeaviatesMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsDocumentsWeaviatesMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsDocumentsWeaviatesMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsDocumentsWeaviatesMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsDocumentsWeaviatesNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsDocumentsWeaviatesNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: GetObjectsDocumentsWeaviatesMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: GetObjectsDocumentsWeaviatesMoveTo
}

input GetObjectsDocumentsWeaviatesNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsDocumentsWeaviatesSortInpObj {
  """
  Specify the sort order, either ascending (asc) which is default or descending (desc)
  """
  order: GetObjectsDocumentsWeaviatesSortInpObjTypeEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Get',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]
}

enum GetObjectsDocumentsWeaviatesSortInpObjTypeEnum {
  asc
  desc
}

input GetObjectsDocumentsWeaviatesWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input GetObjectsDocumentsWeaviatesWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input GetObjectsDocumentsWeaviatesWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: GetObjectsDocumentsWeaviatesWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: GetObjectsDocumentsWeaviatesWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsDocumentsWeaviatesWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsDocumentsWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsDocumentsWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsDocumentsWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsDocumentsWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsDocumentsWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsDocumentsWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsDocumentsWeaviates
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input GetObjectsDocumentsWeaviatesWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsDocumentsWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsDocumentsWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsDocumentsWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsDocumentsWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsDocumentsWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsDocumentsWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsDocumentsWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsDocumentsWeaviates
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum GetObjectsDocumentsWeaviatesWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Specify the property of the class to group by"""
input GetObjectsMessagesWeaviateGroupByInpObj {
  """Specify the number of groups to be created"""
  groups: Int!

  """Specify the number of max objects in group"""
  objectsPerGroup: Int!

  """
  Specify the path from the objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsMessagesWeaviateGroupInpObj {
  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!
  type: GetObjectsMessagesWeaviateGroupInpObjTypeEnum
}

enum GetObjectsMessagesWeaviateGroupInpObjTypeEnum {
  closest
  merge
}

input GetObjectsMessagesWeaviateHybridGetBm25InpObj {
  """The properties to search in"""
  properties: [String]

  """The query to search for"""
  query: String
}

"""Hybrid search"""
input GetObjectsMessagesWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Algorithm used for fusing results from vector and keyword search"""
  fusionType: FusionEnum

  """Which properties should be included in the sparse search"""
  properties: [String]

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input GetObjectsMessagesWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsMessagesWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsMessagesWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsMessagesWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsMessagesWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsMessagesWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsMessagesWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsMessagesWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: GetObjectsMessagesWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: GetObjectsMessagesWeaviateMoveTo
}

input GetObjectsMessagesWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsMessagesWeaviateSortInpObj {
  """
  Specify the sort order, either ascending (asc) which is default or descending (desc)
  """
  order: GetObjectsMessagesWeaviateSortInpObjTypeEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Get',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]
}

enum GetObjectsMessagesWeaviateSortInpObjTypeEnum {
  asc
  desc
}

input GetObjectsMessagesWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input GetObjectsMessagesWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input GetObjectsMessagesWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: GetObjectsMessagesWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: GetObjectsMessagesWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsMessagesWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsMessagesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsMessagesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsMessagesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsMessagesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsMessagesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsMessagesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsMessagesWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input GetObjectsMessagesWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsMessagesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsMessagesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsMessagesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsMessagesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsMessagesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsMessagesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsMessagesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsMessagesWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum GetObjectsMessagesWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""An object used to get %ss on a local Weaviate"""
type GetObjectsObj {
  ChatsWeaviate(
    """Show the results after a given ID"""
    after: String
    ask: QnATransformersGetObjectsChatsWeaviateAskInpObj

    """
    Cut off number of results after the Nth extrema. Off by default, negative numbers mean off.
    """
    autocut: Int
    bm25: GetObjectsChatsWeaviateHybridGetBm25InpObj
    group: GetObjectsChatsWeaviateGroupInpObj
    groupBy: GetObjectsChatsWeaviateGroupByInpObj
    hybrid: GetObjectsChatsWeaviateHybridInpObj

    """Limit the results set (usually fewer results mean faster queries)"""
    limit: Int
    nearObject: GetObjectsChatsWeaviateNearObjectInpObj
    nearText: GetObjectsChatsWeaviateNearTextInpObj
    nearVector: GetObjectsChatsWeaviateNearVectorInpObj

    """Show the results after the first x results (pagination option)"""
    offset: Int
    sort: [GetObjectsChatsWeaviateSortInpObj]

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: GetObjectsChatsWeaviateWhereInpObj
  ): [ChatsWeaviate]
  DocumentsWeaviates(
    """Show the results after a given ID"""
    after: String
    ask: QnATransformersGetObjectsDocumentsWeaviatesAskInpObj

    """
    Cut off number of results after the Nth extrema. Off by default, negative numbers mean off.
    """
    autocut: Int
    bm25: GetObjectsDocumentsWeaviatesHybridGetBm25InpObj
    group: GetObjectsDocumentsWeaviatesGroupInpObj
    groupBy: GetObjectsDocumentsWeaviatesGroupByInpObj
    hybrid: GetObjectsDocumentsWeaviatesHybridInpObj

    """Limit the results set (usually fewer results mean faster queries)"""
    limit: Int
    nearObject: GetObjectsDocumentsWeaviatesNearObjectInpObj
    nearText: GetObjectsDocumentsWeaviatesNearTextInpObj
    nearVector: GetObjectsDocumentsWeaviatesNearVectorInpObj

    """Show the results after the first x results (pagination option)"""
    offset: Int
    sort: [GetObjectsDocumentsWeaviatesSortInpObj]

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: GetObjectsDocumentsWeaviatesWhereInpObj
  ): [DocumentsWeaviates]
  MessagesWeaviate(
    """Show the results after a given ID"""
    after: String
    ask: QnATransformersGetObjectsMessagesWeaviateAskInpObj

    """
    Cut off number of results after the Nth extrema. Off by default, negative numbers mean off.
    """
    autocut: Int
    bm25: GetObjectsMessagesWeaviateHybridGetBm25InpObj
    group: GetObjectsMessagesWeaviateGroupInpObj
    groupBy: GetObjectsMessagesWeaviateGroupByInpObj
    hybrid: GetObjectsMessagesWeaviateHybridInpObj

    """Limit the results set (usually fewer results mean faster queries)"""
    limit: Int
    nearObject: GetObjectsMessagesWeaviateNearObjectInpObj
    nearText: GetObjectsMessagesWeaviateNearTextInpObj
    nearVector: GetObjectsMessagesWeaviateNearVectorInpObj

    """Show the results after the first x results (pagination option)"""
    offset: Int
    sort: [GetObjectsMessagesWeaviateSortInpObj]

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: GetObjectsMessagesWeaviateWhereInpObj
  ): [MessagesWeaviate]
  RolesWeaviate(
    """Show the results after a given ID"""
    after: String
    ask: QnATransformersGetObjectsRolesWeaviateAskInpObj

    """
    Cut off number of results after the Nth extrema. Off by default, negative numbers mean off.
    """
    autocut: Int
    bm25: GetObjectsRolesWeaviateHybridGetBm25InpObj
    group: GetObjectsRolesWeaviateGroupInpObj
    groupBy: GetObjectsRolesWeaviateGroupByInpObj
    hybrid: GetObjectsRolesWeaviateHybridInpObj

    """Limit the results set (usually fewer results mean faster queries)"""
    limit: Int
    nearObject: GetObjectsRolesWeaviateNearObjectInpObj
    nearText: GetObjectsRolesWeaviateNearTextInpObj
    nearVector: GetObjectsRolesWeaviateNearVectorInpObj

    """Show the results after the first x results (pagination option)"""
    offset: Int
    sort: [GetObjectsRolesWeaviateSortInpObj]

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: GetObjectsRolesWeaviateWhereInpObj
  ): [RolesWeaviate]
  TemplatesWeaviates(
    """Show the results after a given ID"""
    after: String
    ask: QnATransformersGetObjectsTemplatesWeaviatesAskInpObj

    """
    Cut off number of results after the Nth extrema. Off by default, negative numbers mean off.
    """
    autocut: Int
    bm25: GetObjectsTemplatesWeaviatesHybridGetBm25InpObj
    group: GetObjectsTemplatesWeaviatesGroupInpObj
    groupBy: GetObjectsTemplatesWeaviatesGroupByInpObj
    hybrid: GetObjectsTemplatesWeaviatesHybridInpObj

    """Limit the results set (usually fewer results mean faster queries)"""
    limit: Int
    nearObject: GetObjectsTemplatesWeaviatesNearObjectInpObj
    nearText: GetObjectsTemplatesWeaviatesNearTextInpObj
    nearVector: GetObjectsTemplatesWeaviatesNearVectorInpObj

    """Show the results after the first x results (pagination option)"""
    offset: Int
    sort: [GetObjectsTemplatesWeaviatesSortInpObj]

    """
    Filter options for a local Get query, used to convert the result to the specified filters
    """
    where: GetObjectsTemplatesWeaviatesWhereInpObj
  ): [TemplatesWeaviates]
}

"""Specify the property of the class to group by"""
input GetObjectsRolesWeaviateGroupByInpObj {
  """Specify the number of groups to be created"""
  groups: Int!

  """Specify the number of max objects in group"""
  objectsPerGroup: Int!

  """
  Specify the path from the objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsRolesWeaviateGroupInpObj {
  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!
  type: GetObjectsRolesWeaviateGroupInpObjTypeEnum
}

enum GetObjectsRolesWeaviateGroupInpObjTypeEnum {
  closest
  merge
}

input GetObjectsRolesWeaviateHybridGetBm25InpObj {
  """The properties to search in"""
  properties: [String]

  """The query to search for"""
  query: String
}

"""Hybrid search"""
input GetObjectsRolesWeaviateHybridInpObj {
  """Search weight"""
  alpha: Float

  """Algorithm used for fusing results from vector and keyword search"""
  fusionType: FusionEnum

  """Which properties should be included in the sparse search"""
  properties: [String]

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input GetObjectsRolesWeaviateMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsRolesWeaviateMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsRolesWeaviateMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsRolesWeaviateMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsRolesWeaviateMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsRolesWeaviateMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsRolesWeaviateNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsRolesWeaviateNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: GetObjectsRolesWeaviateMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: GetObjectsRolesWeaviateMoveTo
}

input GetObjectsRolesWeaviateNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsRolesWeaviateSortInpObj {
  """
  Specify the sort order, either ascending (asc) which is default or descending (desc)
  """
  order: GetObjectsRolesWeaviateSortInpObjTypeEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Get',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]
}

enum GetObjectsRolesWeaviateSortInpObjTypeEnum {
  asc
  desc
}

input GetObjectsRolesWeaviateWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input GetObjectsRolesWeaviateWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input GetObjectsRolesWeaviateWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: GetObjectsRolesWeaviateWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: GetObjectsRolesWeaviateWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsRolesWeaviateWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsRolesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsRolesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsRolesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsRolesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsRolesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsRolesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsRolesWeaviate
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input GetObjectsRolesWeaviateWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsRolesWeaviateWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsRolesWeaviateWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsRolesWeaviate

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsRolesWeaviateWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsRolesWeaviate

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsRolesWeaviate

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsRolesWeaviate

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsRolesWeaviate
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum GetObjectsRolesWeaviateWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

"""Specify the property of the class to group by"""
input GetObjectsTemplatesWeaviatesGroupByInpObj {
  """Specify the number of groups to be created"""
  groups: Int!

  """Specify the number of max objects in group"""
  objectsPerGroup: Int!

  """
  Specify the path from the objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsTemplatesWeaviatesGroupInpObj {
  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!
  type: GetObjectsTemplatesWeaviatesGroupInpObjTypeEnum
}

enum GetObjectsTemplatesWeaviatesGroupInpObjTypeEnum {
  closest
  merge
}

input GetObjectsTemplatesWeaviatesHybridGetBm25InpObj {
  """The properties to search in"""
  properties: [String]

  """The query to search for"""
  query: String
}

"""Hybrid search"""
input GetObjectsTemplatesWeaviatesHybridInpObj {
  """Search weight"""
  alpha: Float

  """Algorithm used for fusing results from vector and keyword search"""
  fusionType: FusionEnum

  """Which properties should be included in the sparse search"""
  properties: [String]

  """Query string"""
  query: String

  """Vector search"""
  vector: [Float]
}

input GetObjectsTemplatesWeaviatesMoveAwayFrom {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsTemplatesWeaviatesMoveAwayFromMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsTemplatesWeaviatesMoveAwayFromMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsTemplatesWeaviatesMoveTo {
  """
  Keywords are a list of search terms. Array type, e.g. ["keyword 1", "keyword 2"]
  """
  concepts: [String]

  """
  The force to apply for a particular movements. Must be between 0 and 1 where 0
  is equivalent to no movement and 1 is equivalent to largest movement possible
  """
  force: Float!

  """objects"""
  objects: [GetObjectsTemplatesWeaviatesMoveToMovementObjectsInpObj]
}

"""Movement Object"""
input GetObjectsTemplatesWeaviatesMoveToMovementObjectsInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """id of an object"""
  id: String
}

input GetObjectsTemplatesWeaviatesNearObjectInpObj {
  """
  Concept identifier in the beacon format, such as weaviate://<hostname>/<kind>/id
  """
  beacon: String

  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Concept identifier in the uuid format"""
  id: String
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsTemplatesWeaviatesNearTextInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float
  concepts: [String]!

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveAwayFrom: GetObjectsTemplatesWeaviatesMoveAwayFrom

  """
  Move your search term closer to or further away from another vector described by keywords
  """
  moveTo: GetObjectsTemplatesWeaviatesMoveTo
}

input GetObjectsTemplatesWeaviatesNearVectorInpObj {
  """
  Normalized Distance between the result item and the search vector. Normalized
  to be between 0 (identical vectors) and 1 (perfect opposite).
  """
  certainty: Float

  """
  The required degree of similarity between an object's characteristics and the provided filter values
  """
  distance: Float

  """Target vector to be used in kNN search"""
  vector: [Float]!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsTemplatesWeaviatesSortInpObj {
  """
  Specify the sort order, either ascending (asc) which is default or descending (desc)
  """
  order: GetObjectsTemplatesWeaviatesSortInpObjTypeEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Get',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]
}

enum GetObjectsTemplatesWeaviatesSortInpObjTypeEnum {
  asc
  desc
}

input GetObjectsTemplatesWeaviatesWhereGeoRangeDistanceInpObj {
  """The maximum distance from the point specified geoCoordinates."""
  max: Float!
}

input GetObjectsTemplatesWeaviatesWhereGeoRangeGeoCoordinatesInpObj {
  """
  The latitude (in decimal format) of the geoCoordinates to search around.
  """
  latitude: Float!

  """
  The longitude (in decimal format) of the geoCoordinates to search around.
  """
  longitude: Float!
}

input GetObjectsTemplatesWeaviatesWhereGeoRangeInpObj {
  """The distance from the point specified via geoCoordinates."""
  distance: GetObjectsTemplatesWeaviatesWhereGeoRangeDistanceInpObj!

  """The geoCoordinates that form the center point of the search."""
  geoCoordinates: GetObjectsTemplatesWeaviatesWhereGeoRangeGeoCoordinatesInpObj!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input GetObjectsTemplatesWeaviatesWhereInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsTemplatesWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsTemplatesWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsTemplatesWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsTemplatesWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsTemplatesWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsTemplatesWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsTemplatesWeaviates
}

"""
An object containing the Operands that can be applied to a 'where' filter
"""
input GetObjectsTemplatesWeaviatesWhereOperandsInpObj {
  """Contains the Operands that can be applied to a 'where' filter"""
  operands: [GetObjectsTemplatesWeaviatesWhereOperandsInpObj]

  """Contains the Operators that can be applied to a 'where' filter"""
  operator: GetObjectsTemplatesWeaviatesWhereOperatorEnum

  """
  Specify the path from the Objects fields to the property name (e.g. ['Things',
  'City', 'population'] leads to the 'population' property of a 'City' object)
  """
  path: [String]

  """Specify a Boolean value that the target property will be compared to"""
  valueBoolean: BooleanGetObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueDate: TextDateGetObjectsTemplatesWeaviates

  """
  Specify both geo-coordinates (latitude and longitude as decimals) and a
  maximum distance from the described coordinates. The search will return any
  result which is located less than or equal to the specified maximum distance
  in km away from the specified point.
  """
  valueGeoRange: GetObjectsTemplatesWeaviatesWhereGeoRangeInpObj

  """Specify an Integer value that the target property will be compared to"""
  valueInt: IntGetObjectsTemplatesWeaviates

  """Specify a Float value that the target property will be compared to"""
  valueNumber: FloatGetObjectsTemplatesWeaviates

  """Specify a String value that the target property will be compared to"""
  valueString: TextStringGetObjectsTemplatesWeaviates

  """Specify a Text value that the target property will be compared to"""
  valueText: TextGetObjectsTemplatesWeaviates
}

"""
An object containing the Operators that can be applied to a 'where' filter
"""
enum GetObjectsTemplatesWeaviatesWhereOperatorEnum {
  And
  ContainsAll
  ContainsAny
  Equal
  GreaterThan
  GreaterThanEqual
  IsNull
  LessThan
  LessThanEqual
  Like
  Not
  NotEqual
  Or
  WithinGeoRange
}

input GetVectorDataInput {
  chat_id: String!
  content: String!
}

type GetVectorDataOutput {
  content: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""Int or Int[]"""
scalar IntAggregateObjectsChatsWeaviate

"""Int or Int[]"""
scalar IntAggregateObjectsDocumentsWeaviates

"""Int or Int[]"""
scalar IntAggregateObjectsMessagesWeaviate

"""Int or Int[]"""
scalar IntAggregateObjectsRolesWeaviate

"""Int or Int[]"""
scalar IntAggregateObjectsTemplatesWeaviates

"""Int or Int[]"""
scalar IntGetObjectsChatsWeaviate

"""Int or Int[]"""
scalar IntGetObjectsDocumentsWeaviates

"""Int or Int[]"""
scalar IntGetObjectsMessagesWeaviate

"""Int or Int[]"""
scalar IntGetObjectsRolesWeaviate

"""Int or Int[]"""
scalar IntGetObjectsTemplatesWeaviates

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

input MakeBetterPromtInput {
  content: String!
}

type MakeBetterPromtOutput {
  content: String!
}

"""
columns and relationships of "messages"
"""
type messages {
  chatId: uuid!

  """An object relationship"""
  chats: chats
  content: String
  createdAt: timestamptz
  data(
    """JSON select path"""
    path: String
  ): json
  id: uuid!
  role: String
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

input messages_aggregate_bool_exp {
  count: messages_aggregate_bool_exp_count
}

input messages_aggregate_bool_exp_count {
  arguments: [messages_select_column!]
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
}

"""
order by aggregate values of table "messages"
"""
input messages_aggregate_order_by {
  count: order_by
  max: messages_max_order_by
  min: messages_min_order_by
}

"""
input type for inserting array relation for remote table "messages"
"""
input messages_arr_rel_insert_input {
  data: [messages_insert_input!]!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  chatId: uuid_comparison_exp
  chats: chats_bool_exp
  content: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  data: json_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  chatId: uuid
  chats: chats_obj_rel_insert_input
  content: String
  createdAt: timestamptz
  data: json
  id: uuid
  role: String
}

"""aggregate max on columns"""
type messages_max_fields {
  chatId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  role: String
}

"""
order by max() on columns of table "messages"
"""
input messages_max_order_by {
  chatId: order_by
  content: order_by
  createdAt: order_by
  id: order_by
  role: order_by
}

"""aggregate min on columns"""
type messages_min_fields {
  chatId: uuid
  content: String
  createdAt: timestamptz
  id: uuid
  role: String
}

"""
order by min() on columns of table "messages"
"""
input messages_min_order_by {
  chatId: order_by
  content: order_by
  createdAt: order_by
  id: order_by
  role: order_by
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  chatId: order_by
  chats: chats_order_by
  content: order_by
  createdAt: order_by
  data: order_by
  id: order_by
  role: order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: uuid!
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  chatId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  role
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  chatId: uuid
  content: String
  createdAt: timestamptz
  data: json
  id: uuid
  role: String
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  chatId: uuid
  content: String
  createdAt: timestamptz
  data: json
  id: uuid
  role: String
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  chatId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  id

  """column name"""
  role
}

input messages_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

type MessagesWeaviate {
  _additional: MessagesWeaviateAdditional
  chatId: String
  content: String
}

type MessagesWeaviateAdditional {
  answer: MessagesWeaviateAdditionalAnswer
  certainty: Float
  classification: MessagesWeaviateAdditionalClassification
  creationTimeUnix: String
  distance: Float
  explainScore: String
  featureProjection(algorithm: String, dimensions: Int, iterations: Int, learningRate: Int, perplexity: Int): MessagesWeaviateAdditionalFeatureProjection
  group: MessagesWeaviateAdditionalGroup

  """The UUID of a Object, assigned by its local Weaviate"""
  id: String
  lastUpdateTimeUnix: String
  rerank(
    """Property to rank from"""
    property: String

    """Properties which contains text"""
    query: String
  ): [MessagesWeaviateAdditionalReranker]
  score: String
  vector: [Float]
}

type MessagesWeaviateAdditionalAnswer {
  endPosition: Int
  hasAnswer: Boolean
  property: String
  result: String
  startPosition: Int
}

type MessagesWeaviateAdditionalClassification {
  basedOn: [String]
  classifiedFields: [String]
  completed: String
  id: String
  scope: [String]
}

type MessagesWeaviateAdditionalFeatureProjection {
  vector: [Float]
}

type MessagesWeaviateAdditionalGroup {
  count: Int
  groupedBy: MessagesWeaviateAdditionalGroupGroupedBy
  hits: [MessagesWeaviateAdditionalGroupHits]
  id: Int
  maxDistance: Float
  minDistance: Float
}

type MessagesWeaviateAdditionalGroupGroupedBy {
  path: [String]
  value: String
}

type MessagesWeaviateAdditionalGroupHits {
  _additional: MessagesWeaviateAdditionalGroupHitsAdditional
  chatId: String
  content: String
}

type MessagesWeaviateAdditionalGroupHitsAdditional {
  distance: Float
  id: String
  vector: [Float]
}

type MessagesWeaviateAdditionalReranker {
  score: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: uuid!): accounts

  """
  delete data from the table: "ai_categories"
  """
  delete_ai_categories(
    """filter the rows which have to be deleted"""
    where: ai_categories_bool_exp!
  ): ai_categories_mutation_response

  """
  delete single row from the table: "ai_categories"
  """
  delete_ai_categories_by_pk(id: Int!): ai_categories

  """
  delete data from the table: "ai_models"
  """
  delete_ai_models(
    """filter the rows which have to be deleted"""
    where: ai_models_bool_exp!
  ): ai_models_mutation_response

  """
  delete single row from the table: "ai_models"
  """
  delete_ai_models_by_pk(id: uuid!): ai_models

  """
  delete data from the table: "chats"
  """
  delete_chats(
    """filter the rows which have to be deleted"""
    where: chats_bool_exp!
  ): chats_mutation_response

  """
  delete single row from the table: "chats"
  """
  delete_chats_by_pk(id: uuid!): chats

  """
  delete data from the table: "directus_files"
  """
  delete_directus_files(
    """filter the rows which have to be deleted"""
    where: directus_files_bool_exp!
  ): directus_files_mutation_response

  """
  delete single row from the table: "directus_files"
  """
  delete_directus_files_by_pk(id: uuid!): directus_files

  """
  delete data from the table: "directus_users"
  """
  delete_directus_users(
    """filter the rows which have to be deleted"""
    where: directus_users_bool_exp!
  ): directus_users_mutation_response

  """
  delete single row from the table: "directus_users"
  """
  delete_directus_users_by_pk(id: uuid!): directus_users

  """
  delete data from the table: "documents"
  """
  delete_documents(
    """filter the rows which have to be deleted"""
    where: documents_bool_exp!
  ): documents_mutation_response

  """
  delete single row from the table: "documents"
  """
  delete_documents_by_pk(id: uuid!): documents

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: uuid!): messages

  """
  delete data from the table: "password_reset_tokens"
  """
  delete_password_reset_tokens(
    """filter the rows which have to be deleted"""
    where: password_reset_tokens_bool_exp!
  ): password_reset_tokens_mutation_response

  """
  delete single row from the table: "password_reset_tokens"
  """
  delete_password_reset_tokens_by_pk(token: uuid!): password_reset_tokens

  """
  delete data from the table: "payment_history"
  """
  delete_payment_history(
    """filter the rows which have to be deleted"""
    where: payment_history_bool_exp!
  ): payment_history_mutation_response

  """
  delete single row from the table: "payment_history"
  """
  delete_payment_history_by_pk(id: uuid!): payment_history

  """
  delete data from the table: "plan_categories"
  """
  delete_plan_categories(
    """filter the rows which have to be deleted"""
    where: plan_categories_bool_exp!
  ): plan_categories_mutation_response

  """
  delete single row from the table: "plan_categories"
  """
  delete_plan_categories_by_pk(id: Int!): plan_categories

  """
  delete data from the table: "plans"
  """
  delete_plans(
    """filter the rows which have to be deleted"""
    where: plans_bool_exp!
  ): plans_mutation_response

  """
  delete single row from the table: "plans"
  """
  delete_plans_by_pk(id: uuid!): plans

  """
  delete data from the table: "profile_categories"
  """
  delete_profile_categories(
    """filter the rows which have to be deleted"""
    where: profile_categories_bool_exp!
  ): profile_categories_mutation_response

  """
  delete single row from the table: "profile_categories"
  """
  delete_profile_categories_by_pk(id: Int!): profile_categories

  """
  delete data from the table: "provider_type"
  """
  delete_provider_type(
    """filter the rows which have to be deleted"""
    where: provider_type_bool_exp!
  ): provider_type_mutation_response

  """
  delete single row from the table: "provider_type"
  """
  delete_provider_type_by_pk(value: String!): provider_type

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    """filter the rows which have to be deleted"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(sessionToken: String!): sessions

  """
  delete data from the table: "template_categories"
  """
  delete_template_categories(
    """filter the rows which have to be deleted"""
    where: template_categories_bool_exp!
  ): template_categories_mutation_response

  """
  delete single row from the table: "template_categories"
  """
  delete_template_categories_by_pk(id: Int!): template_categories

  """
  delete data from the table: "template_tags"
  """
  delete_template_tags(
    """filter the rows which have to be deleted"""
    where: template_tags_bool_exp!
  ): template_tags_mutation_response

  """
  delete single row from the table: "template_tags"
  """
  delete_template_tags_by_pk(id: Int!): template_tags

  """
  delete data from the table: "templates"
  """
  delete_templates(
    """filter the rows which have to be deleted"""
    where: templates_bool_exp!
  ): templates_mutation_response

  """
  delete single row from the table: "templates"
  """
  delete_templates_by_pk(id: uuid!): templates

  """
  delete data from the table: "tokens_history"
  """
  delete_tokens_history(
    """filter the rows which have to be deleted"""
    where: tokens_history_bool_exp!
  ): tokens_history_mutation_response

  """
  delete single row from the table: "tokens_history"
  """
  delete_tokens_history_by_pk(id: uuid!): tokens_history

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "verification_tokens"
  """
  delete_verification_tokens(
    """filter the rows which have to be deleted"""
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response

  """
  delete single row from the table: "verification_tokens"
  """
  delete_verification_tokens_by_pk(token: String!): verification_tokens

  """
  delete data from the table: "wallets"
  """
  delete_wallets(
    """filter the rows which have to be deleted"""
    where: wallets_bool_exp!
  ): wallets_mutation_response

  """
  delete single row from the table: "wallets"
  """
  delete_wallets_by_pk(id: uuid!): wallets

  """get_data_from_db"""
  getVectorData(data: GetVectorDataInput!): GetVectorDataOutput

  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    """the rows to be inserted"""
    objects: [accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    """the row to be inserted"""
    object: accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts

  """
  insert data into the table: "ai_categories"
  """
  insert_ai_categories(
    """the rows to be inserted"""
    objects: [ai_categories_insert_input!]!

    """upsert condition"""
    on_conflict: ai_categories_on_conflict
  ): ai_categories_mutation_response

  """
  insert a single row into the table: "ai_categories"
  """
  insert_ai_categories_one(
    """the row to be inserted"""
    object: ai_categories_insert_input!

    """upsert condition"""
    on_conflict: ai_categories_on_conflict
  ): ai_categories

  """
  insert data into the table: "ai_models"
  """
  insert_ai_models(
    """the rows to be inserted"""
    objects: [ai_models_insert_input!]!

    """upsert condition"""
    on_conflict: ai_models_on_conflict
  ): ai_models_mutation_response

  """
  insert a single row into the table: "ai_models"
  """
  insert_ai_models_one(
    """the row to be inserted"""
    object: ai_models_insert_input!

    """upsert condition"""
    on_conflict: ai_models_on_conflict
  ): ai_models

  """
  insert data into the table: "chats"
  """
  insert_chats(
    """the rows to be inserted"""
    objects: [chats_insert_input!]!

    """upsert condition"""
    on_conflict: chats_on_conflict
  ): chats_mutation_response

  """
  insert a single row into the table: "chats"
  """
  insert_chats_one(
    """the row to be inserted"""
    object: chats_insert_input!

    """upsert condition"""
    on_conflict: chats_on_conflict
  ): chats

  """
  insert data into the table: "directus_files"
  """
  insert_directus_files(
    """the rows to be inserted"""
    objects: [directus_files_insert_input!]!

    """upsert condition"""
    on_conflict: directus_files_on_conflict
  ): directus_files_mutation_response

  """
  insert a single row into the table: "directus_files"
  """
  insert_directus_files_one(
    """the row to be inserted"""
    object: directus_files_insert_input!

    """upsert condition"""
    on_conflict: directus_files_on_conflict
  ): directus_files

  """
  insert data into the table: "directus_users"
  """
  insert_directus_users(
    """the rows to be inserted"""
    objects: [directus_users_insert_input!]!

    """upsert condition"""
    on_conflict: directus_users_on_conflict
  ): directus_users_mutation_response

  """
  insert a single row into the table: "directus_users"
  """
  insert_directus_users_one(
    """the row to be inserted"""
    object: directus_users_insert_input!

    """upsert condition"""
    on_conflict: directus_users_on_conflict
  ): directus_users

  """
  insert data into the table: "documents"
  """
  insert_documents(
    """the rows to be inserted"""
    objects: [documents_insert_input!]!

    """upsert condition"""
    on_conflict: documents_on_conflict
  ): documents_mutation_response

  """
  insert a single row into the table: "documents"
  """
  insert_documents_one(
    """the row to be inserted"""
    object: documents_insert_input!

    """upsert condition"""
    on_conflict: documents_on_conflict
  ): documents

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "password_reset_tokens"
  """
  insert_password_reset_tokens(
    """the rows to be inserted"""
    objects: [password_reset_tokens_insert_input!]!

    """upsert condition"""
    on_conflict: password_reset_tokens_on_conflict
  ): password_reset_tokens_mutation_response

  """
  insert a single row into the table: "password_reset_tokens"
  """
  insert_password_reset_tokens_one(
    """the row to be inserted"""
    object: password_reset_tokens_insert_input!

    """upsert condition"""
    on_conflict: password_reset_tokens_on_conflict
  ): password_reset_tokens

  """
  insert data into the table: "payment_history"
  """
  insert_payment_history(
    """the rows to be inserted"""
    objects: [payment_history_insert_input!]!

    """upsert condition"""
    on_conflict: payment_history_on_conflict
  ): payment_history_mutation_response

  """
  insert a single row into the table: "payment_history"
  """
  insert_payment_history_one(
    """the row to be inserted"""
    object: payment_history_insert_input!

    """upsert condition"""
    on_conflict: payment_history_on_conflict
  ): payment_history

  """
  insert data into the table: "plan_categories"
  """
  insert_plan_categories(
    """the rows to be inserted"""
    objects: [plan_categories_insert_input!]!

    """upsert condition"""
    on_conflict: plan_categories_on_conflict
  ): plan_categories_mutation_response

  """
  insert a single row into the table: "plan_categories"
  """
  insert_plan_categories_one(
    """the row to be inserted"""
    object: plan_categories_insert_input!

    """upsert condition"""
    on_conflict: plan_categories_on_conflict
  ): plan_categories

  """
  insert data into the table: "plans"
  """
  insert_plans(
    """the rows to be inserted"""
    objects: [plans_insert_input!]!

    """upsert condition"""
    on_conflict: plans_on_conflict
  ): plans_mutation_response

  """
  insert a single row into the table: "plans"
  """
  insert_plans_one(
    """the row to be inserted"""
    object: plans_insert_input!

    """upsert condition"""
    on_conflict: plans_on_conflict
  ): plans

  """
  insert data into the table: "profile_categories"
  """
  insert_profile_categories(
    """the rows to be inserted"""
    objects: [profile_categories_insert_input!]!

    """upsert condition"""
    on_conflict: profile_categories_on_conflict
  ): profile_categories_mutation_response

  """
  insert a single row into the table: "profile_categories"
  """
  insert_profile_categories_one(
    """the row to be inserted"""
    object: profile_categories_insert_input!

    """upsert condition"""
    on_conflict: profile_categories_on_conflict
  ): profile_categories

  """
  insert data into the table: "provider_type"
  """
  insert_provider_type(
    """the rows to be inserted"""
    objects: [provider_type_insert_input!]!

    """upsert condition"""
    on_conflict: provider_type_on_conflict
  ): provider_type_mutation_response

  """
  insert a single row into the table: "provider_type"
  """
  insert_provider_type_one(
    """the row to be inserted"""
    object: provider_type_insert_input!

    """upsert condition"""
    on_conflict: provider_type_on_conflict
  ): provider_type

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    """the rows to be inserted"""
    objects: [sessions_insert_input!]!

    """upsert condition"""
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    """the row to be inserted"""
    object: sessions_insert_input!

    """upsert condition"""
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "template_categories"
  """
  insert_template_categories(
    """the rows to be inserted"""
    objects: [template_categories_insert_input!]!

    """upsert condition"""
    on_conflict: template_categories_on_conflict
  ): template_categories_mutation_response

  """
  insert a single row into the table: "template_categories"
  """
  insert_template_categories_one(
    """the row to be inserted"""
    object: template_categories_insert_input!

    """upsert condition"""
    on_conflict: template_categories_on_conflict
  ): template_categories

  """
  insert data into the table: "template_tags"
  """
  insert_template_tags(
    """the rows to be inserted"""
    objects: [template_tags_insert_input!]!

    """upsert condition"""
    on_conflict: template_tags_on_conflict
  ): template_tags_mutation_response

  """
  insert a single row into the table: "template_tags"
  """
  insert_template_tags_one(
    """the row to be inserted"""
    object: template_tags_insert_input!

    """upsert condition"""
    on_conflict: template_tags_on_conflict
  ): template_tags

  """
  insert data into the table: "templates"
  """
  insert_templates(
    """the rows to be inserted"""
    objects: [templates_insert_input!]!

    """upsert condition"""
    on_conflict: templates_on_conflict
  ): templates_mutation_response

  """
  insert a single row into the table: "templates"
  """
  insert_templates_one(
    """the row to be inserted"""
    object: templates_insert_input!

    """upsert condition"""
    on_conflict: templates_on_conflict
  ): templates

  """
  insert data into the table: "tokens_history"
  """
  insert_tokens_history(
    """the rows to be inserted"""
    objects: [tokens_history_insert_input!]!

    """upsert condition"""
    on_conflict: tokens_history_on_conflict
  ): tokens_history_mutation_response

  """
  insert a single row into the table: "tokens_history"
  """
  insert_tokens_history_one(
    """the row to be inserted"""
    object: tokens_history_insert_input!

    """upsert condition"""
    on_conflict: tokens_history_on_conflict
  ): tokens_history

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "verification_tokens"
  """
  insert_verification_tokens(
    """the rows to be inserted"""
    objects: [verification_tokens_insert_input!]!

    """upsert condition"""
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens_mutation_response

  """
  insert a single row into the table: "verification_tokens"
  """
  insert_verification_tokens_one(
    """the row to be inserted"""
    object: verification_tokens_insert_input!

    """upsert condition"""
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens

  """
  insert data into the table: "wallets"
  """
  insert_wallets(
    """the rows to be inserted"""
    objects: [wallets_insert_input!]!

    """upsert condition"""
    on_conflict: wallets_on_conflict
  ): wallets_mutation_response

  """
  insert a single row into the table: "wallets"
  """
  insert_wallets_one(
    """the row to be inserted"""
    object: wallets_insert_input!

    """upsert condition"""
    on_conflict: wallets_on_conflict
  ): wallets

  """better promt"""
  makeBetterPromt(data: MakeBetterPromtInput!): MakeBetterPromtOutput

  """
  update data of the table: "accounts"
  """
  update_accounts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]

  """
  update data of the table: "ai_categories"
  """
  update_ai_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ai_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ai_categories_set_input

    """filter the rows which have to be updated"""
    where: ai_categories_bool_exp!
  ): ai_categories_mutation_response

  """
  update single row of the table: "ai_categories"
  """
  update_ai_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ai_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ai_categories_set_input
    pk_columns: ai_categories_pk_columns_input!
  ): ai_categories

  """
  update multiples rows of table: "ai_categories"
  """
  update_ai_categories_many(
    """updates to execute, in order"""
    updates: [ai_categories_updates!]!
  ): [ai_categories_mutation_response]

  """
  update data of the table: "ai_models"
  """
  update_ai_models(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ai_models_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ai_models_set_input

    """filter the rows which have to be updated"""
    where: ai_models_bool_exp!
  ): ai_models_mutation_response

  """
  update single row of the table: "ai_models"
  """
  update_ai_models_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ai_models_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ai_models_set_input
    pk_columns: ai_models_pk_columns_input!
  ): ai_models

  """
  update multiples rows of table: "ai_models"
  """
  update_ai_models_many(
    """updates to execute, in order"""
    updates: [ai_models_updates!]!
  ): [ai_models_mutation_response]

  """
  update data of the table: "chats"
  """
  update_chats(
    """sets the columns of the filtered rows to the given values"""
    _set: chats_set_input

    """filter the rows which have to be updated"""
    where: chats_bool_exp!
  ): chats_mutation_response

  """
  update single row of the table: "chats"
  """
  update_chats_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: chats_set_input
    pk_columns: chats_pk_columns_input!
  ): chats

  """
  update multiples rows of table: "chats"
  """
  update_chats_many(
    """updates to execute, in order"""
    updates: [chats_updates!]!
  ): [chats_mutation_response]

  """
  update data of the table: "directus_files"
  """
  update_directus_files(
    """increments the numeric columns with given value of the filtered values"""
    _inc: directus_files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: directus_files_set_input

    """filter the rows which have to be updated"""
    where: directus_files_bool_exp!
  ): directus_files_mutation_response

  """
  update single row of the table: "directus_files"
  """
  update_directus_files_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: directus_files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: directus_files_set_input
    pk_columns: directus_files_pk_columns_input!
  ): directus_files

  """
  update multiples rows of table: "directus_files"
  """
  update_directus_files_many(
    """updates to execute, in order"""
    updates: [directus_files_updates!]!
  ): [directus_files_mutation_response]

  """
  update data of the table: "directus_users"
  """
  update_directus_users(
    """sets the columns of the filtered rows to the given values"""
    _set: directus_users_set_input

    """filter the rows which have to be updated"""
    where: directus_users_bool_exp!
  ): directus_users_mutation_response

  """
  update single row of the table: "directus_users"
  """
  update_directus_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: directus_users_set_input
    pk_columns: directus_users_pk_columns_input!
  ): directus_users

  """
  update multiples rows of table: "directus_users"
  """
  update_directus_users_many(
    """updates to execute, in order"""
    updates: [directus_users_updates!]!
  ): [directus_users_mutation_response]

  """
  update data of the table: "documents"
  """
  update_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_set_input

    """filter the rows which have to be updated"""
    where: documents_bool_exp!
  ): documents_mutation_response

  """
  update single row of the table: "documents"
  """
  update_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_set_input
    pk_columns: documents_pk_columns_input!
  ): documents

  """
  update multiples rows of table: "documents"
  """
  update_documents_many(
    """updates to execute, in order"""
    updates: [documents_updates!]!
  ): [documents_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "password_reset_tokens"
  """
  update_password_reset_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: password_reset_tokens_set_input

    """filter the rows which have to be updated"""
    where: password_reset_tokens_bool_exp!
  ): password_reset_tokens_mutation_response

  """
  update single row of the table: "password_reset_tokens"
  """
  update_password_reset_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: password_reset_tokens_set_input
    pk_columns: password_reset_tokens_pk_columns_input!
  ): password_reset_tokens

  """
  update multiples rows of table: "password_reset_tokens"
  """
  update_password_reset_tokens_many(
    """updates to execute, in order"""
    updates: [password_reset_tokens_updates!]!
  ): [password_reset_tokens_mutation_response]

  """
  update data of the table: "payment_history"
  """
  update_payment_history(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_history_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_history_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_history_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_history_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_history_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_history_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_history_set_input

    """filter the rows which have to be updated"""
    where: payment_history_bool_exp!
  ): payment_history_mutation_response

  """
  update single row of the table: "payment_history"
  """
  update_payment_history_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: payment_history_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: payment_history_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: payment_history_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: payment_history_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: payment_history_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: payment_history_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: payment_history_set_input
    pk_columns: payment_history_pk_columns_input!
  ): payment_history

  """
  update multiples rows of table: "payment_history"
  """
  update_payment_history_many(
    """updates to execute, in order"""
    updates: [payment_history_updates!]!
  ): [payment_history_mutation_response]

  """
  update data of the table: "plan_categories"
  """
  update_plan_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: plan_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: plan_categories_set_input

    """filter the rows which have to be updated"""
    where: plan_categories_bool_exp!
  ): plan_categories_mutation_response

  """
  update single row of the table: "plan_categories"
  """
  update_plan_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: plan_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: plan_categories_set_input
    pk_columns: plan_categories_pk_columns_input!
  ): plan_categories

  """
  update multiples rows of table: "plan_categories"
  """
  update_plan_categories_many(
    """updates to execute, in order"""
    updates: [plan_categories_updates!]!
  ): [plan_categories_mutation_response]

  """
  update data of the table: "plans"
  """
  update_plans(
    """increments the numeric columns with given value of the filtered values"""
    _inc: plans_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: plans_set_input

    """filter the rows which have to be updated"""
    where: plans_bool_exp!
  ): plans_mutation_response

  """
  update single row of the table: "plans"
  """
  update_plans_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: plans_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: plans_set_input
    pk_columns: plans_pk_columns_input!
  ): plans

  """
  update multiples rows of table: "plans"
  """
  update_plans_many(
    """updates to execute, in order"""
    updates: [plans_updates!]!
  ): [plans_mutation_response]

  """
  update data of the table: "profile_categories"
  """
  update_profile_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profile_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profile_categories_set_input

    """filter the rows which have to be updated"""
    where: profile_categories_bool_exp!
  ): profile_categories_mutation_response

  """
  update single row of the table: "profile_categories"
  """
  update_profile_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profile_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profile_categories_set_input
    pk_columns: profile_categories_pk_columns_input!
  ): profile_categories

  """
  update multiples rows of table: "profile_categories"
  """
  update_profile_categories_many(
    """updates to execute, in order"""
    updates: [profile_categories_updates!]!
  ): [profile_categories_mutation_response]

  """
  update data of the table: "provider_type"
  """
  update_provider_type(
    """sets the columns of the filtered rows to the given values"""
    _set: provider_type_set_input

    """filter the rows which have to be updated"""
    where: provider_type_bool_exp!
  ): provider_type_mutation_response

  """
  update single row of the table: "provider_type"
  """
  update_provider_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: provider_type_set_input
    pk_columns: provider_type_pk_columns_input!
  ): provider_type

  """
  update multiples rows of table: "provider_type"
  """
  update_provider_type_many(
    """updates to execute, in order"""
    updates: [provider_type_updates!]!
  ): [provider_type_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "sessions"
  """
  update_sessions(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input

    """filter the rows which have to be updated"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    """updates to execute, in order"""
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]

  """
  update data of the table: "template_categories"
  """
  update_template_categories(
    """increments the numeric columns with given value of the filtered values"""
    _inc: template_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: template_categories_set_input

    """filter the rows which have to be updated"""
    where: template_categories_bool_exp!
  ): template_categories_mutation_response

  """
  update single row of the table: "template_categories"
  """
  update_template_categories_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: template_categories_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: template_categories_set_input
    pk_columns: template_categories_pk_columns_input!
  ): template_categories

  """
  update multiples rows of table: "template_categories"
  """
  update_template_categories_many(
    """updates to execute, in order"""
    updates: [template_categories_updates!]!
  ): [template_categories_mutation_response]

  """
  update data of the table: "template_tags"
  """
  update_template_tags(
    """increments the numeric columns with given value of the filtered values"""
    _inc: template_tags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: template_tags_set_input

    """filter the rows which have to be updated"""
    where: template_tags_bool_exp!
  ): template_tags_mutation_response

  """
  update single row of the table: "template_tags"
  """
  update_template_tags_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: template_tags_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: template_tags_set_input
    pk_columns: template_tags_pk_columns_input!
  ): template_tags

  """
  update multiples rows of table: "template_tags"
  """
  update_template_tags_many(
    """updates to execute, in order"""
    updates: [template_tags_updates!]!
  ): [template_tags_mutation_response]

  """
  update data of the table: "templates"
  """
  update_templates(
    """increments the numeric columns with given value of the filtered values"""
    _inc: templates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: templates_set_input

    """filter the rows which have to be updated"""
    where: templates_bool_exp!
  ): templates_mutation_response

  """
  update single row of the table: "templates"
  """
  update_templates_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: templates_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: templates_set_input
    pk_columns: templates_pk_columns_input!
  ): templates

  """
  update multiples rows of table: "templates"
  """
  update_templates_many(
    """updates to execute, in order"""
    updates: [templates_updates!]!
  ): [templates_mutation_response]

  """
  update data of the table: "tokens_history"
  """
  update_tokens_history(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tokens_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tokens_history_set_input

    """filter the rows which have to be updated"""
    where: tokens_history_bool_exp!
  ): tokens_history_mutation_response

  """
  update single row of the table: "tokens_history"
  """
  update_tokens_history_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tokens_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tokens_history_set_input
    pk_columns: tokens_history_pk_columns_input!
  ): tokens_history

  """
  update multiples rows of table: "tokens_history"
  """
  update_tokens_history_many(
    """updates to execute, in order"""
    updates: [tokens_history_updates!]!
  ): [tokens_history_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "verification_tokens"
  """
  update_verification_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_tokens_set_input

    """filter the rows which have to be updated"""
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response

  """
  update single row of the table: "verification_tokens"
  """
  update_verification_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_tokens_set_input
    pk_columns: verification_tokens_pk_columns_input!
  ): verification_tokens

  """
  update multiples rows of table: "verification_tokens"
  """
  update_verification_tokens_many(
    """updates to execute, in order"""
    updates: [verification_tokens_updates!]!
  ): [verification_tokens_mutation_response]

  """
  update data of the table: "wallets"
  """
  update_wallets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: wallets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: wallets_set_input

    """filter the rows which have to be updated"""
    where: wallets_bool_exp!
  ): wallets_mutation_response

  """
  update single row of the table: "wallets"
  """
  update_wallets_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: wallets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: wallets_set_input
    pk_columns: wallets_pk_columns_input!
  ): wallets

  """
  update multiples rows of table: "wallets"
  """
  update_wallets_many(
    """updates to execute, in order"""
    updates: [wallets_updates!]!
  ): [wallets_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "password_reset_tokens"
"""
type password_reset_tokens {
  email: String!
  expires: timestamptz!
  token: uuid!
}

"""
aggregated selection of "password_reset_tokens"
"""
type password_reset_tokens_aggregate {
  aggregate: password_reset_tokens_aggregate_fields
  nodes: [password_reset_tokens!]!
}

"""
aggregate fields of "password_reset_tokens"
"""
type password_reset_tokens_aggregate_fields {
  count(columns: [password_reset_tokens_select_column!], distinct: Boolean): Int!
  max: password_reset_tokens_max_fields
  min: password_reset_tokens_min_fields
}

"""
Boolean expression to filter rows from the table "password_reset_tokens". All fields are combined with a logical 'AND'.
"""
input password_reset_tokens_bool_exp {
  _and: [password_reset_tokens_bool_exp!]
  _not: password_reset_tokens_bool_exp
  _or: [password_reset_tokens_bool_exp!]
  email: String_comparison_exp
  expires: timestamptz_comparison_exp
  token: uuid_comparison_exp
}

"""
unique or primary key constraints on table "password_reset_tokens"
"""
enum password_reset_tokens_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  password_reset_token_email_key

  """
  unique or primary key constraint on columns "token"
  """
  password_reset_token_pkey
}

"""
input type for inserting data into table "password_reset_tokens"
"""
input password_reset_tokens_insert_input {
  email: String
  expires: timestamptz
  token: uuid
}

"""aggregate max on columns"""
type password_reset_tokens_max_fields {
  email: String
  expires: timestamptz
  token: uuid
}

"""aggregate min on columns"""
type password_reset_tokens_min_fields {
  email: String
  expires: timestamptz
  token: uuid
}

"""
response of any mutation on the table "password_reset_tokens"
"""
type password_reset_tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [password_reset_tokens!]!
}

"""
on_conflict condition type for table "password_reset_tokens"
"""
input password_reset_tokens_on_conflict {
  constraint: password_reset_tokens_constraint!
  update_columns: [password_reset_tokens_update_column!]! = []
  where: password_reset_tokens_bool_exp
}

"""Ordering options when selecting data from "password_reset_tokens"."""
input password_reset_tokens_order_by {
  email: order_by
  expires: order_by
  token: order_by
}

"""primary key columns input for table: password_reset_tokens"""
input password_reset_tokens_pk_columns_input {
  token: uuid!
}

"""
select columns of table "password_reset_tokens"
"""
enum password_reset_tokens_select_column {
  """column name"""
  email

  """column name"""
  expires

  """column name"""
  token
}

"""
input type for updating data in table "password_reset_tokens"
"""
input password_reset_tokens_set_input {
  email: String
  expires: timestamptz
  token: uuid
}

"""
Streaming cursor of the table "password_reset_tokens"
"""
input password_reset_tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: password_reset_tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input password_reset_tokens_stream_cursor_value_input {
  email: String
  expires: timestamptz
  token: uuid
}

"""
update columns of table "password_reset_tokens"
"""
enum password_reset_tokens_update_column {
  """column name"""
  email

  """column name"""
  expires

  """column name"""
  token
}

input password_reset_tokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: password_reset_tokens_set_input

  """filter the rows which have to be updated"""
  where: password_reset_tokens_bool_exp!
}

"""
columns and relationships of "payment_history"
"""
type payment_history {
  amount: Int
  card: String
  card_exp_date: String
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  date: timestamptz!
  four_last: String
  id: uuid!
  invoice_id: String
  plan: String
  status: Int!
  transaction_id: Int!
  user_id: uuid!
}

"""
aggregated selection of "payment_history"
"""
type payment_history_aggregate {
  aggregate: payment_history_aggregate_fields
  nodes: [payment_history!]!
}

"""
aggregate fields of "payment_history"
"""
type payment_history_aggregate_fields {
  avg: payment_history_avg_fields
  count(columns: [payment_history_select_column!], distinct: Boolean): Int!
  max: payment_history_max_fields
  min: payment_history_min_fields
  stddev: payment_history_stddev_fields
  stddev_pop: payment_history_stddev_pop_fields
  stddev_samp: payment_history_stddev_samp_fields
  sum: payment_history_sum_fields
  var_pop: payment_history_var_pop_fields
  var_samp: payment_history_var_samp_fields
  variance: payment_history_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input payment_history_append_input {
  data: jsonb
}

"""aggregate avg on columns"""
type payment_history_avg_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""
Boolean expression to filter rows from the table "payment_history". All fields are combined with a logical 'AND'.
"""
input payment_history_bool_exp {
  _and: [payment_history_bool_exp!]
  _not: payment_history_bool_exp
  _or: [payment_history_bool_exp!]
  amount: Int_comparison_exp
  card: String_comparison_exp
  card_exp_date: String_comparison_exp
  data: jsonb_comparison_exp
  date: timestamptz_comparison_exp
  four_last: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: String_comparison_exp
  plan: String_comparison_exp
  status: Int_comparison_exp
  transaction_id: Int_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "payment_history"
"""
enum payment_history_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payment_history_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input payment_history_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input payment_history_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input payment_history_delete_key_input {
  data: String
}

"""
input type for incrementing numeric columns in table "payment_history"
"""
input payment_history_inc_input {
  amount: Int
  status: Int
  transaction_id: Int
}

"""
input type for inserting data into table "payment_history"
"""
input payment_history_insert_input {
  amount: Int
  card: String
  card_exp_date: String
  data: jsonb
  date: timestamptz
  four_last: String
  id: uuid
  invoice_id: String
  plan: String
  status: Int
  transaction_id: Int
  user_id: uuid
}

"""aggregate max on columns"""
type payment_history_max_fields {
  amount: Int
  card: String
  card_exp_date: String
  date: timestamptz
  four_last: String
  id: uuid
  invoice_id: String
  plan: String
  status: Int
  transaction_id: Int
  user_id: uuid
}

"""aggregate min on columns"""
type payment_history_min_fields {
  amount: Int
  card: String
  card_exp_date: String
  date: timestamptz
  four_last: String
  id: uuid
  invoice_id: String
  plan: String
  status: Int
  transaction_id: Int
  user_id: uuid
}

"""
response of any mutation on the table "payment_history"
"""
type payment_history_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_history!]!
}

"""
on_conflict condition type for table "payment_history"
"""
input payment_history_on_conflict {
  constraint: payment_history_constraint!
  update_columns: [payment_history_update_column!]! = []
  where: payment_history_bool_exp
}

"""Ordering options when selecting data from "payment_history"."""
input payment_history_order_by {
  amount: order_by
  card: order_by
  card_exp_date: order_by
  data: order_by
  date: order_by
  four_last: order_by
  id: order_by
  invoice_id: order_by
  plan: order_by
  status: order_by
  transaction_id: order_by
  user_id: order_by
}

"""primary key columns input for table: payment_history"""
input payment_history_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input payment_history_prepend_input {
  data: jsonb
}

"""
select columns of table "payment_history"
"""
enum payment_history_select_column {
  """column name"""
  amount

  """column name"""
  card

  """column name"""
  card_exp_date

  """column name"""
  data

  """column name"""
  date

  """column name"""
  four_last

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  plan

  """column name"""
  status

  """column name"""
  transaction_id

  """column name"""
  user_id
}

"""
input type for updating data in table "payment_history"
"""
input payment_history_set_input {
  amount: Int
  card: String
  card_exp_date: String
  data: jsonb
  date: timestamptz
  four_last: String
  id: uuid
  invoice_id: String
  plan: String
  status: Int
  transaction_id: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type payment_history_stddev_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""aggregate stddev_pop on columns"""
type payment_history_stddev_pop_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""aggregate stddev_samp on columns"""
type payment_history_stddev_samp_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""
Streaming cursor of the table "payment_history"
"""
input payment_history_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_history_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_history_stream_cursor_value_input {
  amount: Int
  card: String
  card_exp_date: String
  data: jsonb
  date: timestamptz
  four_last: String
  id: uuid
  invoice_id: String
  plan: String
  status: Int
  transaction_id: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type payment_history_sum_fields {
  amount: Int
  status: Int
  transaction_id: Int
}

"""
update columns of table "payment_history"
"""
enum payment_history_update_column {
  """column name"""
  amount

  """column name"""
  card

  """column name"""
  card_exp_date

  """column name"""
  data

  """column name"""
  date

  """column name"""
  four_last

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  plan

  """column name"""
  status

  """column name"""
  transaction_id

  """column name"""
  user_id
}

input payment_history_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: payment_history_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: payment_history_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: payment_history_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: payment_history_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: payment_history_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: payment_history_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: payment_history_set_input

  """filter the rows which have to be updated"""
  where: payment_history_bool_exp!
}

"""aggregate var_pop on columns"""
type payment_history_var_pop_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""aggregate var_samp on columns"""
type payment_history_var_samp_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""aggregate variance on columns"""
type payment_history_variance_fields {
  amount: Float
  status: Float
  transaction_id: Float
}

"""
columns and relationships of "plan_categories"
"""
type plan_categories {
  icon: String
  id: Int!
  name: String
  title: String
}

"""
aggregated selection of "plan_categories"
"""
type plan_categories_aggregate {
  aggregate: plan_categories_aggregate_fields
  nodes: [plan_categories!]!
}

"""
aggregate fields of "plan_categories"
"""
type plan_categories_aggregate_fields {
  avg: plan_categories_avg_fields
  count(columns: [plan_categories_select_column!], distinct: Boolean): Int!
  max: plan_categories_max_fields
  min: plan_categories_min_fields
  stddev: plan_categories_stddev_fields
  stddev_pop: plan_categories_stddev_pop_fields
  stddev_samp: plan_categories_stddev_samp_fields
  sum: plan_categories_sum_fields
  var_pop: plan_categories_var_pop_fields
  var_samp: plan_categories_var_samp_fields
  variance: plan_categories_variance_fields
}

"""aggregate avg on columns"""
type plan_categories_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "plan_categories". All fields are combined with a logical 'AND'.
"""
input plan_categories_bool_exp {
  _and: [plan_categories_bool_exp!]
  _not: plan_categories_bool_exp
  _or: [plan_categories_bool_exp!]
  icon: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "plan_categories"
"""
enum plan_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  plan_categories_pkey
}

"""
input type for incrementing numeric columns in table "plan_categories"
"""
input plan_categories_inc_input {
  id: Int
}

"""
input type for inserting data into table "plan_categories"
"""
input plan_categories_insert_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate max on columns"""
type plan_categories_max_fields {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate min on columns"""
type plan_categories_min_fields {
  icon: String
  id: Int
  name: String
  title: String
}

"""
response of any mutation on the table "plan_categories"
"""
type plan_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [plan_categories!]!
}

"""
on_conflict condition type for table "plan_categories"
"""
input plan_categories_on_conflict {
  constraint: plan_categories_constraint!
  update_columns: [plan_categories_update_column!]! = []
  where: plan_categories_bool_exp
}

"""Ordering options when selecting data from "plan_categories"."""
input plan_categories_order_by {
  icon: order_by
  id: order_by
  name: order_by
  title: order_by
}

"""primary key columns input for table: plan_categories"""
input plan_categories_pk_columns_input {
  id: Int!
}

"""
select columns of table "plan_categories"
"""
enum plan_categories_select_column {
  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

"""
input type for updating data in table "plan_categories"
"""
input plan_categories_set_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate stddev on columns"""
type plan_categories_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type plan_categories_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type plan_categories_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "plan_categories"
"""
input plan_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: plan_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input plan_categories_stream_cursor_value_input {
  icon: String
  id: Int
  name: String
  title: String
}

"""aggregate sum on columns"""
type plan_categories_sum_fields {
  id: Int
}

"""
update columns of table "plan_categories"
"""
enum plan_categories_update_column {
  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

input plan_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: plan_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: plan_categories_set_input

  """filter the rows which have to be updated"""
  where: plan_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type plan_categories_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type plan_categories_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type plan_categories_variance_fields {
  id: Float
}

"""
columns and relationships of "plans"
"""
type plans {
  description: String!
  id: uuid!
  name: String!
  price: Int!
  tokens: Int!
}

"""
aggregated selection of "plans"
"""
type plans_aggregate {
  aggregate: plans_aggregate_fields
  nodes: [plans!]!
}

"""
aggregate fields of "plans"
"""
type plans_aggregate_fields {
  avg: plans_avg_fields
  count(columns: [plans_select_column!], distinct: Boolean): Int!
  max: plans_max_fields
  min: plans_min_fields
  stddev: plans_stddev_fields
  stddev_pop: plans_stddev_pop_fields
  stddev_samp: plans_stddev_samp_fields
  sum: plans_sum_fields
  var_pop: plans_var_pop_fields
  var_samp: plans_var_samp_fields
  variance: plans_variance_fields
}

"""aggregate avg on columns"""
type plans_avg_fields {
  price: Float
  tokens: Float
}

"""
Boolean expression to filter rows from the table "plans". All fields are combined with a logical 'AND'.
"""
input plans_bool_exp {
  _and: [plans_bool_exp!]
  _not: plans_bool_exp
  _or: [plans_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  price: Int_comparison_exp
  tokens: Int_comparison_exp
}

"""
unique or primary key constraints on table "plans"
"""
enum plans_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  plans_pkey
}

"""
input type for incrementing numeric columns in table "plans"
"""
input plans_inc_input {
  price: Int
  tokens: Int
}

"""
input type for inserting data into table "plans"
"""
input plans_insert_input {
  description: String
  id: uuid
  name: String
  price: Int
  tokens: Int
}

"""aggregate max on columns"""
type plans_max_fields {
  description: String
  id: uuid
  name: String
  price: Int
  tokens: Int
}

"""aggregate min on columns"""
type plans_min_fields {
  description: String
  id: uuid
  name: String
  price: Int
  tokens: Int
}

"""
response of any mutation on the table "plans"
"""
type plans_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [plans!]!
}

"""
on_conflict condition type for table "plans"
"""
input plans_on_conflict {
  constraint: plans_constraint!
  update_columns: [plans_update_column!]! = []
  where: plans_bool_exp
}

"""Ordering options when selecting data from "plans"."""
input plans_order_by {
  description: order_by
  id: order_by
  name: order_by
  price: order_by
  tokens: order_by
}

"""primary key columns input for table: plans"""
input plans_pk_columns_input {
  id: uuid!
}

"""
select columns of table "plans"
"""
enum plans_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  price

  """column name"""
  tokens
}

"""
input type for updating data in table "plans"
"""
input plans_set_input {
  description: String
  id: uuid
  name: String
  price: Int
  tokens: Int
}

"""aggregate stddev on columns"""
type plans_stddev_fields {
  price: Float
  tokens: Float
}

"""aggregate stddev_pop on columns"""
type plans_stddev_pop_fields {
  price: Float
  tokens: Float
}

"""aggregate stddev_samp on columns"""
type plans_stddev_samp_fields {
  price: Float
  tokens: Float
}

"""
Streaming cursor of the table "plans"
"""
input plans_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: plans_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input plans_stream_cursor_value_input {
  description: String
  id: uuid
  name: String
  price: Int
  tokens: Int
}

"""aggregate sum on columns"""
type plans_sum_fields {
  price: Int
  tokens: Int
}

"""
update columns of table "plans"
"""
enum plans_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  price

  """column name"""
  tokens
}

input plans_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: plans_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: plans_set_input

  """filter the rows which have to be updated"""
  where: plans_bool_exp!
}

"""aggregate var_pop on columns"""
type plans_var_pop_fields {
  price: Float
  tokens: Float
}

"""aggregate var_samp on columns"""
type plans_var_samp_fields {
  price: Float
  tokens: Float
}

"""aggregate variance on columns"""
type plans_variance_fields {
  price: Float
  tokens: Float
}

"""the profile layout buttons data"""
type profile_categories {
  id: Int!
  name: bpchar
  title: String!
}

"""
aggregated selection of "profile_categories"
"""
type profile_categories_aggregate {
  aggregate: profile_categories_aggregate_fields
  nodes: [profile_categories!]!
}

"""
aggregate fields of "profile_categories"
"""
type profile_categories_aggregate_fields {
  avg: profile_categories_avg_fields
  count(columns: [profile_categories_select_column!], distinct: Boolean): Int!
  max: profile_categories_max_fields
  min: profile_categories_min_fields
  stddev: profile_categories_stddev_fields
  stddev_pop: profile_categories_stddev_pop_fields
  stddev_samp: profile_categories_stddev_samp_fields
  sum: profile_categories_sum_fields
  var_pop: profile_categories_var_pop_fields
  var_samp: profile_categories_var_samp_fields
  variance: profile_categories_variance_fields
}

"""aggregate avg on columns"""
type profile_categories_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "profile_categories". All fields are combined with a logical 'AND'.
"""
input profile_categories_bool_exp {
  _and: [profile_categories_bool_exp!]
  _not: profile_categories_bool_exp
  _or: [profile_categories_bool_exp!]
  id: Int_comparison_exp
  name: bpchar_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "profile_categories"
"""
enum profile_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  profile_categories_pkey
}

"""
input type for incrementing numeric columns in table "profile_categories"
"""
input profile_categories_inc_input {
  id: Int
}

"""
input type for inserting data into table "profile_categories"
"""
input profile_categories_insert_input {
  id: Int
  name: bpchar
  title: String
}

"""aggregate max on columns"""
type profile_categories_max_fields {
  id: Int
  name: bpchar
  title: String
}

"""aggregate min on columns"""
type profile_categories_min_fields {
  id: Int
  name: bpchar
  title: String
}

"""
response of any mutation on the table "profile_categories"
"""
type profile_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [profile_categories!]!
}

"""
on_conflict condition type for table "profile_categories"
"""
input profile_categories_on_conflict {
  constraint: profile_categories_constraint!
  update_columns: [profile_categories_update_column!]! = []
  where: profile_categories_bool_exp
}

"""Ordering options when selecting data from "profile_categories"."""
input profile_categories_order_by {
  id: order_by
  name: order_by
  title: order_by
}

"""primary key columns input for table: profile_categories"""
input profile_categories_pk_columns_input {
  id: Int!
}

"""
select columns of table "profile_categories"
"""
enum profile_categories_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

"""
input type for updating data in table "profile_categories"
"""
input profile_categories_set_input {
  id: Int
  name: bpchar
  title: String
}

"""aggregate stddev on columns"""
type profile_categories_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type profile_categories_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type profile_categories_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "profile_categories"
"""
input profile_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: profile_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input profile_categories_stream_cursor_value_input {
  id: Int
  name: bpchar
  title: String
}

"""aggregate sum on columns"""
type profile_categories_sum_fields {
  id: Int
}

"""
update columns of table "profile_categories"
"""
enum profile_categories_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

input profile_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: profile_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: profile_categories_set_input

  """filter the rows which have to be updated"""
  where: profile_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type profile_categories_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type profile_categories_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type profile_categories_variance_fields {
  id: Float
}

"""
columns and relationships of "provider_type"
"""
type provider_type {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!
  value: String!
}

"""
aggregated selection of "provider_type"
"""
type provider_type_aggregate {
  aggregate: provider_type_aggregate_fields
  nodes: [provider_type!]!
}

"""
aggregate fields of "provider_type"
"""
type provider_type_aggregate_fields {
  count(columns: [provider_type_select_column!], distinct: Boolean): Int!
  max: provider_type_max_fields
  min: provider_type_min_fields
}

"""
Boolean expression to filter rows from the table "provider_type". All fields are combined with a logical 'AND'.
"""
input provider_type_bool_exp {
  _and: [provider_type_bool_exp!]
  _not: provider_type_bool_exp
  _or: [provider_type_bool_exp!]
  accounts: accounts_bool_exp
  accounts_aggregate: accounts_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "provider_type"
"""
enum provider_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  provider_type_pkey
}

"""
input type for inserting data into table "provider_type"
"""
input provider_type_insert_input {
  accounts: accounts_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type provider_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type provider_type_min_fields {
  value: String
}

"""
response of any mutation on the table "provider_type"
"""
type provider_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [provider_type!]!
}

"""
input type for inserting object relation for remote table "provider_type"
"""
input provider_type_obj_rel_insert_input {
  data: provider_type_insert_input!

  """upsert condition"""
  on_conflict: provider_type_on_conflict
}

"""
on_conflict condition type for table "provider_type"
"""
input provider_type_on_conflict {
  constraint: provider_type_constraint!
  update_columns: [provider_type_update_column!]! = []
  where: provider_type_bool_exp
}

"""Ordering options when selecting data from "provider_type"."""
input provider_type_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: provider_type"""
input provider_type_pk_columns_input {
  value: String!
}

"""
select columns of table "provider_type"
"""
enum provider_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "provider_type"
"""
input provider_type_set_input {
  value: String
}

"""
Streaming cursor of the table "provider_type"
"""
input provider_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: provider_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input provider_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "provider_type"
"""
enum provider_type_update_column {
  """column name"""
  value
}

input provider_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: provider_type_set_input

  """filter the rows which have to be updated"""
  where: provider_type_bool_exp!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersAggregateChatsWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersAggregateDocumentsWeaviatesAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersAggregateMessagesWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersAggregateRolesWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersAggregateTemplatesWeaviatesAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersGetObjectsChatsWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersGetObjectsDocumentsWeaviatesAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersGetObjectsMessagesWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersGetObjectsRolesWeaviateAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

"""
An object containing filter options for a local Get query, used to convert the result to the specified filters
"""
input QnATransformersGetObjectsTemplatesWeaviatesAskInpObj {
  """Properties which contains text"""
  properties: [String]

  """Question to be answered"""
  question: String!
}

type query_root {
  """
  Filter options for a local Aggregate query, used to convert the result to the specified filters
  """
  Aggregate: AggregateObjectsObj

  """Get Objects on a local Weaviate"""
  Get: GetObjectsObj

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: uuid!): accounts

  """
  fetch data from the table: "ai_categories"
  """
  ai_categories(
    """distinct select on columns"""
    distinct_on: [ai_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_categories_order_by!]

    """filter the rows returned"""
    where: ai_categories_bool_exp
  ): [ai_categories!]!

  """
  fetch aggregated fields from the table: "ai_categories"
  """
  ai_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [ai_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_categories_order_by!]

    """filter the rows returned"""
    where: ai_categories_bool_exp
  ): ai_categories_aggregate!

  """fetch data from the table: "ai_categories" using primary key columns"""
  ai_categories_by_pk(id: Int!): ai_categories

  """
  fetch data from the table: "ai_models"
  """
  ai_models(
    """distinct select on columns"""
    distinct_on: [ai_models_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_models_order_by!]

    """filter the rows returned"""
    where: ai_models_bool_exp
  ): [ai_models!]!

  """
  fetch aggregated fields from the table: "ai_models"
  """
  ai_models_aggregate(
    """distinct select on columns"""
    distinct_on: [ai_models_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_models_order_by!]

    """filter the rows returned"""
    where: ai_models_bool_exp
  ): ai_models_aggregate!

  """fetch data from the table: "ai_models" using primary key columns"""
  ai_models_by_pk(id: uuid!): ai_models

  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): [chats!]!

  """An aggregate relationship"""
  chats_aggregate(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): chats_aggregate!

  """fetch data from the table: "chats" using primary key columns"""
  chats_by_pk(id: uuid!): chats

  """
  fetch data from the table: "directus_files"
  """
  directus_files(
    """distinct select on columns"""
    distinct_on: [directus_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_files_order_by!]

    """filter the rows returned"""
    where: directus_files_bool_exp
  ): [directus_files!]!

  """
  fetch aggregated fields from the table: "directus_files"
  """
  directus_files_aggregate(
    """distinct select on columns"""
    distinct_on: [directus_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_files_order_by!]

    """filter the rows returned"""
    where: directus_files_bool_exp
  ): directus_files_aggregate!

  """fetch data from the table: "directus_files" using primary key columns"""
  directus_files_by_pk(id: uuid!): directus_files

  """
  fetch data from the table: "directus_users"
  """
  directus_users(
    """distinct select on columns"""
    distinct_on: [directus_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_users_order_by!]

    """filter the rows returned"""
    where: directus_users_bool_exp
  ): [directus_users!]!

  """
  fetch aggregated fields from the table: "directus_users"
  """
  directus_users_aggregate(
    """distinct select on columns"""
    distinct_on: [directus_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_users_order_by!]

    """filter the rows returned"""
    where: directus_users_bool_exp
  ): directus_users_aggregate!

  """fetch data from the table: "directus_users" using primary key columns"""
  directus_users_by_pk(id: uuid!): directus_users

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!

  """fetch data from the table: "documents" using primary key columns"""
  documents_by_pk(id: uuid!): documents

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table: "password_reset_tokens"
  """
  password_reset_tokens(
    """distinct select on columns"""
    distinct_on: [password_reset_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_reset_tokens_order_by!]

    """filter the rows returned"""
    where: password_reset_tokens_bool_exp
  ): [password_reset_tokens!]!

  """
  fetch aggregated fields from the table: "password_reset_tokens"
  """
  password_reset_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [password_reset_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_reset_tokens_order_by!]

    """filter the rows returned"""
    where: password_reset_tokens_bool_exp
  ): password_reset_tokens_aggregate!

  """
  fetch data from the table: "password_reset_tokens" using primary key columns
  """
  password_reset_tokens_by_pk(token: uuid!): password_reset_tokens

  """
  fetch data from the table: "payment_history"
  """
  payment_history(
    """distinct select on columns"""
    distinct_on: [payment_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_history_order_by!]

    """filter the rows returned"""
    where: payment_history_bool_exp
  ): [payment_history!]!

  """
  fetch aggregated fields from the table: "payment_history"
  """
  payment_history_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_history_order_by!]

    """filter the rows returned"""
    where: payment_history_bool_exp
  ): payment_history_aggregate!

  """fetch data from the table: "payment_history" using primary key columns"""
  payment_history_by_pk(id: uuid!): payment_history

  """
  fetch data from the table: "plan_categories"
  """
  plan_categories(
    """distinct select on columns"""
    distinct_on: [plan_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_categories_order_by!]

    """filter the rows returned"""
    where: plan_categories_bool_exp
  ): [plan_categories!]!

  """
  fetch aggregated fields from the table: "plan_categories"
  """
  plan_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [plan_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_categories_order_by!]

    """filter the rows returned"""
    where: plan_categories_bool_exp
  ): plan_categories_aggregate!

  """fetch data from the table: "plan_categories" using primary key columns"""
  plan_categories_by_pk(id: Int!): plan_categories

  """
  fetch data from the table: "plans"
  """
  plans(
    """distinct select on columns"""
    distinct_on: [plans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plans_order_by!]

    """filter the rows returned"""
    where: plans_bool_exp
  ): [plans!]!

  """
  fetch aggregated fields from the table: "plans"
  """
  plans_aggregate(
    """distinct select on columns"""
    distinct_on: [plans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plans_order_by!]

    """filter the rows returned"""
    where: plans_bool_exp
  ): plans_aggregate!

  """fetch data from the table: "plans" using primary key columns"""
  plans_by_pk(id: uuid!): plans

  """
  fetch data from the table: "profile_categories"
  """
  profile_categories(
    """distinct select on columns"""
    distinct_on: [profile_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_categories_order_by!]

    """filter the rows returned"""
    where: profile_categories_bool_exp
  ): [profile_categories!]!

  """
  fetch aggregated fields from the table: "profile_categories"
  """
  profile_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [profile_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_categories_order_by!]

    """filter the rows returned"""
    where: profile_categories_bool_exp
  ): profile_categories_aggregate!

  """
  fetch data from the table: "profile_categories" using primary key columns
  """
  profile_categories_by_pk(id: Int!): profile_categories

  """
  fetch data from the table: "provider_type"
  """
  provider_type(
    """distinct select on columns"""
    distinct_on: [provider_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [provider_type_order_by!]

    """filter the rows returned"""
    where: provider_type_bool_exp
  ): [provider_type!]!

  """
  fetch aggregated fields from the table: "provider_type"
  """
  provider_type_aggregate(
    """distinct select on columns"""
    distinct_on: [provider_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [provider_type_order_by!]

    """filter the rows returned"""
    where: provider_type_bool_exp
  ): provider_type_aggregate!

  """fetch data from the table: "provider_type" using primary key columns"""
  provider_type_by_pk(value: String!): provider_type

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "sessions" using primary key columns"""
  sessions_by_pk(sessionToken: String!): sessions

  """
  fetch data from the table: "template_categories"
  """
  template_categories(
    """distinct select on columns"""
    distinct_on: [template_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_categories_order_by!]

    """filter the rows returned"""
    where: template_categories_bool_exp
  ): [template_categories!]!

  """
  fetch aggregated fields from the table: "template_categories"
  """
  template_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [template_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_categories_order_by!]

    """filter the rows returned"""
    where: template_categories_bool_exp
  ): template_categories_aggregate!

  """
  fetch data from the table: "template_categories" using primary key columns
  """
  template_categories_by_pk(id: Int!): template_categories

  """
  fetch data from the table: "template_tags"
  """
  template_tags(
    """distinct select on columns"""
    distinct_on: [template_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_tags_order_by!]

    """filter the rows returned"""
    where: template_tags_bool_exp
  ): [template_tags!]!

  """
  fetch aggregated fields from the table: "template_tags"
  """
  template_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [template_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_tags_order_by!]

    """filter the rows returned"""
    where: template_tags_bool_exp
  ): template_tags_aggregate!

  """fetch data from the table: "template_tags" using primary key columns"""
  template_tags_by_pk(id: Int!): template_tags

  """An array relationship"""
  templates(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): [templates!]!

  """An aggregate relationship"""
  templates_aggregate(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): templates_aggregate!

  """fetch data from the table: "templates" using primary key columns"""
  templates_by_pk(id: uuid!): templates

  """
  fetch data from the table: "tokens_history"
  """
  tokens_history(
    """distinct select on columns"""
    distinct_on: [tokens_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_history_order_by!]

    """filter the rows returned"""
    where: tokens_history_bool_exp
  ): [tokens_history!]!

  """
  fetch aggregated fields from the table: "tokens_history"
  """
  tokens_history_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_history_order_by!]

    """filter the rows returned"""
    where: tokens_history_bool_exp
  ): tokens_history_aggregate!

  """fetch data from the table: "tokens_history" using primary key columns"""
  tokens_history_by_pk(id: uuid!): tokens_history

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!

  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens

  """
  fetch data from the table: "wallets"
  """
  wallets(
    """distinct select on columns"""
    distinct_on: [wallets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wallets_order_by!]

    """filter the rows returned"""
    where: wallets_bool_exp
  ): [wallets!]!

  """
  fetch aggregated fields from the table: "wallets"
  """
  wallets_aggregate(
    """distinct select on columns"""
    distinct_on: [wallets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wallets_order_by!]

    """filter the rows returned"""
    where: wallets_bool_exp
  ): wallets_aggregate!

  """fetch data from the table: "wallets" using primary key columns"""
  wallets_by_pk(id: uuid!): wallets
}

"""
columns and relationships of "roles"
"""
type roles {
  """An object relationship"""
  directus_img: directus_files

  """An object relationship"""
  directus_img_min: directus_files
  id: uuid!
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String!
  type: String
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

input roles_aggregate_bool_exp {
  count: roles_aggregate_bool_exp_count
}

input roles_aggregate_bool_exp_count {
  arguments: [roles_select_column!]
  distinct: Boolean
  filter: roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
order by aggregate values of table "roles"
"""
input roles_aggregate_order_by {
  count: order_by
  max: roles_max_order_by
  min: roles_min_order_by
}

"""
input type for inserting array relation for remote table "roles"
"""
input roles_arr_rel_insert_input {
  data: [roles_insert_input!]!

  """upsert condition"""
  on_conflict: roles_on_conflict
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  directus_img: directus_files_bool_exp
  directus_img_min: directus_files_bool_exp
  id: uuid_comparison_exp
  image: uuid_comparison_exp
  image_min: uuid_comparison_exp
  initial_message: String_comparison_exp
  name: String_comparison_exp
  promt: String_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey

  """
  unique or primary key constraint on columns "id"
  """
  roles_uid_key
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  directus_img: directus_files_obj_rel_insert_input
  directus_img_min: directus_files_obj_rel_insert_input
  id: uuid
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String
  type: String
}

"""aggregate max on columns"""
type roles_max_fields {
  id: uuid
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String
  type: String
}

"""
order by max() on columns of table "roles"
"""
input roles_max_order_by {
  id: order_by
  image: order_by
  image_min: order_by
  initial_message: order_by
  name: order_by
  promt: order_by
  title: order_by
  type: order_by
}

"""aggregate min on columns"""
type roles_min_fields {
  id: uuid
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String
  type: String
}

"""
order by min() on columns of table "roles"
"""
input roles_min_order_by {
  id: order_by
  image: order_by
  image_min: order_by
  initial_message: order_by
  name: order_by
  promt: order_by
  title: order_by
  type: order_by
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  directus_img: directus_files_order_by
  directus_img_min: directus_files_order_by
  id: order_by
  image: order_by
  image_min: order_by
  initial_message: order_by
  name: order_by
  promt: order_by
  title: order_by
  type: order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  id

  """column name"""
  image

  """column name"""
  image_min

  """column name"""
  initial_message

  """column name"""
  name

  """column name"""
  promt

  """column name"""
  title

  """column name"""
  type
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  id: uuid
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String
  type: String
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  id: uuid
  image: uuid
  image_min: uuid
  initial_message: String
  name: String
  promt: String
  title: String
  type: String
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  id

  """column name"""
  image

  """column name"""
  image_min

  """column name"""
  initial_message

  """column name"""
  name

  """column name"""
  promt

  """column name"""
  title

  """column name"""
  type
}

input roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

type RolesWeaviate {
  _additional: RolesWeaviateAdditional
  name: String
  title: String
}

type RolesWeaviateAdditional {
  answer: RolesWeaviateAdditionalAnswer
  certainty: Float
  classification: RolesWeaviateAdditionalClassification
  creationTimeUnix: String
  distance: Float
  explainScore: String
  featureProjection(algorithm: String, dimensions: Int, iterations: Int, learningRate: Int, perplexity: Int): RolesWeaviateAdditionalFeatureProjection
  group: RolesWeaviateAdditionalGroup

  """The UUID of a Object, assigned by its local Weaviate"""
  id: String
  lastUpdateTimeUnix: String
  rerank(
    """Property to rank from"""
    property: String

    """Properties which contains text"""
    query: String
  ): [RolesWeaviateAdditionalReranker]
  score: String
  vector: [Float]
}

type RolesWeaviateAdditionalAnswer {
  endPosition: Int
  hasAnswer: Boolean
  property: String
  result: String
  startPosition: Int
}

type RolesWeaviateAdditionalClassification {
  basedOn: [String]
  classifiedFields: [String]
  completed: String
  id: String
  scope: [String]
}

type RolesWeaviateAdditionalFeatureProjection {
  vector: [Float]
}

type RolesWeaviateAdditionalGroup {
  count: Int
  groupedBy: RolesWeaviateAdditionalGroupGroupedBy
  hits: [RolesWeaviateAdditionalGroupHits]
  id: Int
  maxDistance: Float
  minDistance: Float
}

type RolesWeaviateAdditionalGroupGroupedBy {
  path: [String]
  value: String
}

type RolesWeaviateAdditionalGroupHits {
  _additional: RolesWeaviateAdditionalGroupHitsAdditional
  name: String
  title: String
}

type RolesWeaviateAdditionalGroupHitsAdditional {
  distance: Float
  id: String
  vector: [Float]
}

type RolesWeaviateAdditionalReranker {
  score: Float
}

"""
columns and relationships of "sessions"
"""
type sessions {
  expires: timestamptz!
  id: uuid!
  sessionToken: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

input sessions_aggregate_bool_exp {
  count: sessions_aggregate_bool_exp_count
}

input sessions_aggregate_bool_exp_count {
  arguments: [sessions_select_column!]
  distinct: Boolean
  filter: sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
}

"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
}

"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!

  """upsert condition"""
  on_conflict: sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  expires: timestamptz_comparison_exp
  id: uuid_comparison_exp
  sessionToken: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "sessionToken"
  """
  sessions_pkey
}

"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type sessions_max_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""aggregate min on columns"""
type sessions_min_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sessions!]!
}

"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}

"""Ordering options when selecting data from "sessions"."""
input sessions_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: sessions"""
input sessions_pk_columns_input {
  sessionToken: String!
}

"""
select columns of table "sessions"
"""
enum sessions_select_column {
  """column name"""
  expires

  """column name"""
  id

  """column name"""
  sessionToken

  """column name"""
  userId
}

"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sessions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sessions_stream_cursor_value_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
update columns of table "sessions"
"""
enum sessions_update_column {
  """column name"""
  expires

  """column name"""
  id

  """column name"""
  sessionToken

  """column name"""
  userId
}

input sessions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: sessions_set_input

  """filter the rows which have to be updated"""
  where: sessions_bool_exp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: uuid!): accounts

  """
  fetch data from the table in a streaming manner: "accounts"
  """
  accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """
  fetch data from the table: "ai_categories"
  """
  ai_categories(
    """distinct select on columns"""
    distinct_on: [ai_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_categories_order_by!]

    """filter the rows returned"""
    where: ai_categories_bool_exp
  ): [ai_categories!]!

  """
  fetch aggregated fields from the table: "ai_categories"
  """
  ai_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [ai_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_categories_order_by!]

    """filter the rows returned"""
    where: ai_categories_bool_exp
  ): ai_categories_aggregate!

  """fetch data from the table: "ai_categories" using primary key columns"""
  ai_categories_by_pk(id: Int!): ai_categories

  """
  fetch data from the table in a streaming manner: "ai_categories"
  """
  ai_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ai_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: ai_categories_bool_exp
  ): [ai_categories!]!

  """
  fetch data from the table: "ai_models"
  """
  ai_models(
    """distinct select on columns"""
    distinct_on: [ai_models_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_models_order_by!]

    """filter the rows returned"""
    where: ai_models_bool_exp
  ): [ai_models!]!

  """
  fetch aggregated fields from the table: "ai_models"
  """
  ai_models_aggregate(
    """distinct select on columns"""
    distinct_on: [ai_models_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ai_models_order_by!]

    """filter the rows returned"""
    where: ai_models_bool_exp
  ): ai_models_aggregate!

  """fetch data from the table: "ai_models" using primary key columns"""
  ai_models_by_pk(id: uuid!): ai_models

  """
  fetch data from the table in a streaming manner: "ai_models"
  """
  ai_models_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ai_models_stream_cursor_input]!

    """filter the rows returned"""
    where: ai_models_bool_exp
  ): [ai_models!]!

  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): [chats!]!

  """An aggregate relationship"""
  chats_aggregate(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): chats_aggregate!

  """fetch data from the table: "chats" using primary key columns"""
  chats_by_pk(id: uuid!): chats

  """
  fetch data from the table in a streaming manner: "chats"
  """
  chats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chats_stream_cursor_input]!

    """filter the rows returned"""
    where: chats_bool_exp
  ): [chats!]!

  """
  fetch data from the table: "directus_files"
  """
  directus_files(
    """distinct select on columns"""
    distinct_on: [directus_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_files_order_by!]

    """filter the rows returned"""
    where: directus_files_bool_exp
  ): [directus_files!]!

  """
  fetch aggregated fields from the table: "directus_files"
  """
  directus_files_aggregate(
    """distinct select on columns"""
    distinct_on: [directus_files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_files_order_by!]

    """filter the rows returned"""
    where: directus_files_bool_exp
  ): directus_files_aggregate!

  """fetch data from the table: "directus_files" using primary key columns"""
  directus_files_by_pk(id: uuid!): directus_files

  """
  fetch data from the table in a streaming manner: "directus_files"
  """
  directus_files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [directus_files_stream_cursor_input]!

    """filter the rows returned"""
    where: directus_files_bool_exp
  ): [directus_files!]!

  """
  fetch data from the table: "directus_users"
  """
  directus_users(
    """distinct select on columns"""
    distinct_on: [directus_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_users_order_by!]

    """filter the rows returned"""
    where: directus_users_bool_exp
  ): [directus_users!]!

  """
  fetch aggregated fields from the table: "directus_users"
  """
  directus_users_aggregate(
    """distinct select on columns"""
    distinct_on: [directus_users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [directus_users_order_by!]

    """filter the rows returned"""
    where: directus_users_bool_exp
  ): directus_users_aggregate!

  """fetch data from the table: "directus_users" using primary key columns"""
  directus_users_by_pk(id: uuid!): directus_users

  """
  fetch data from the table in a streaming manner: "directus_users"
  """
  directus_users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [directus_users_stream_cursor_input]!

    """filter the rows returned"""
    where: directus_users_bool_exp
  ): [directus_users!]!

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!

  """fetch data from the table: "documents" using primary key columns"""
  documents_by_pk(id: uuid!): documents

  """
  fetch data from the table in a streaming manner: "documents"
  """
  documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [documents_stream_cursor_input]!

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: uuid!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """
  fetch data from the table: "password_reset_tokens"
  """
  password_reset_tokens(
    """distinct select on columns"""
    distinct_on: [password_reset_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_reset_tokens_order_by!]

    """filter the rows returned"""
    where: password_reset_tokens_bool_exp
  ): [password_reset_tokens!]!

  """
  fetch aggregated fields from the table: "password_reset_tokens"
  """
  password_reset_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [password_reset_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [password_reset_tokens_order_by!]

    """filter the rows returned"""
    where: password_reset_tokens_bool_exp
  ): password_reset_tokens_aggregate!

  """
  fetch data from the table: "password_reset_tokens" using primary key columns
  """
  password_reset_tokens_by_pk(token: uuid!): password_reset_tokens

  """
  fetch data from the table in a streaming manner: "password_reset_tokens"
  """
  password_reset_tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [password_reset_tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: password_reset_tokens_bool_exp
  ): [password_reset_tokens!]!

  """
  fetch data from the table: "payment_history"
  """
  payment_history(
    """distinct select on columns"""
    distinct_on: [payment_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_history_order_by!]

    """filter the rows returned"""
    where: payment_history_bool_exp
  ): [payment_history!]!

  """
  fetch aggregated fields from the table: "payment_history"
  """
  payment_history_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_history_order_by!]

    """filter the rows returned"""
    where: payment_history_bool_exp
  ): payment_history_aggregate!

  """fetch data from the table: "payment_history" using primary key columns"""
  payment_history_by_pk(id: uuid!): payment_history

  """
  fetch data from the table in a streaming manner: "payment_history"
  """
  payment_history_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_history_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_history_bool_exp
  ): [payment_history!]!

  """
  fetch data from the table: "plan_categories"
  """
  plan_categories(
    """distinct select on columns"""
    distinct_on: [plan_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_categories_order_by!]

    """filter the rows returned"""
    where: plan_categories_bool_exp
  ): [plan_categories!]!

  """
  fetch aggregated fields from the table: "plan_categories"
  """
  plan_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [plan_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plan_categories_order_by!]

    """filter the rows returned"""
    where: plan_categories_bool_exp
  ): plan_categories_aggregate!

  """fetch data from the table: "plan_categories" using primary key columns"""
  plan_categories_by_pk(id: Int!): plan_categories

  """
  fetch data from the table in a streaming manner: "plan_categories"
  """
  plan_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [plan_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: plan_categories_bool_exp
  ): [plan_categories!]!

  """
  fetch data from the table: "plans"
  """
  plans(
    """distinct select on columns"""
    distinct_on: [plans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plans_order_by!]

    """filter the rows returned"""
    where: plans_bool_exp
  ): [plans!]!

  """
  fetch aggregated fields from the table: "plans"
  """
  plans_aggregate(
    """distinct select on columns"""
    distinct_on: [plans_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [plans_order_by!]

    """filter the rows returned"""
    where: plans_bool_exp
  ): plans_aggregate!

  """fetch data from the table: "plans" using primary key columns"""
  plans_by_pk(id: uuid!): plans

  """
  fetch data from the table in a streaming manner: "plans"
  """
  plans_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [plans_stream_cursor_input]!

    """filter the rows returned"""
    where: plans_bool_exp
  ): [plans!]!

  """
  fetch data from the table: "profile_categories"
  """
  profile_categories(
    """distinct select on columns"""
    distinct_on: [profile_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_categories_order_by!]

    """filter the rows returned"""
    where: profile_categories_bool_exp
  ): [profile_categories!]!

  """
  fetch aggregated fields from the table: "profile_categories"
  """
  profile_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [profile_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_categories_order_by!]

    """filter the rows returned"""
    where: profile_categories_bool_exp
  ): profile_categories_aggregate!

  """
  fetch data from the table: "profile_categories" using primary key columns
  """
  profile_categories_by_pk(id: Int!): profile_categories

  """
  fetch data from the table in a streaming manner: "profile_categories"
  """
  profile_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [profile_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: profile_categories_bool_exp
  ): [profile_categories!]!

  """
  fetch data from the table: "provider_type"
  """
  provider_type(
    """distinct select on columns"""
    distinct_on: [provider_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [provider_type_order_by!]

    """filter the rows returned"""
    where: provider_type_bool_exp
  ): [provider_type!]!

  """
  fetch aggregated fields from the table: "provider_type"
  """
  provider_type_aggregate(
    """distinct select on columns"""
    distinct_on: [provider_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [provider_type_order_by!]

    """filter the rows returned"""
    where: provider_type_bool_exp
  ): provider_type_aggregate!

  """fetch data from the table: "provider_type" using primary key columns"""
  provider_type_by_pk(value: String!): provider_type

  """
  fetch data from the table in a streaming manner: "provider_type"
  """
  provider_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [provider_type_stream_cursor_input]!

    """filter the rows returned"""
    where: provider_type_bool_exp
  ): [provider_type!]!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "sessions" using primary key columns"""
  sessions_by_pk(sessionToken: String!): sessions

  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sessions_stream_cursor_input]!

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch data from the table: "template_categories"
  """
  template_categories(
    """distinct select on columns"""
    distinct_on: [template_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_categories_order_by!]

    """filter the rows returned"""
    where: template_categories_bool_exp
  ): [template_categories!]!

  """
  fetch aggregated fields from the table: "template_categories"
  """
  template_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [template_categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_categories_order_by!]

    """filter the rows returned"""
    where: template_categories_bool_exp
  ): template_categories_aggregate!

  """
  fetch data from the table: "template_categories" using primary key columns
  """
  template_categories_by_pk(id: Int!): template_categories

  """
  fetch data from the table in a streaming manner: "template_categories"
  """
  template_categories_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [template_categories_stream_cursor_input]!

    """filter the rows returned"""
    where: template_categories_bool_exp
  ): [template_categories!]!

  """
  fetch data from the table: "template_tags"
  """
  template_tags(
    """distinct select on columns"""
    distinct_on: [template_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_tags_order_by!]

    """filter the rows returned"""
    where: template_tags_bool_exp
  ): [template_tags!]!

  """
  fetch aggregated fields from the table: "template_tags"
  """
  template_tags_aggregate(
    """distinct select on columns"""
    distinct_on: [template_tags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [template_tags_order_by!]

    """filter the rows returned"""
    where: template_tags_bool_exp
  ): template_tags_aggregate!

  """fetch data from the table: "template_tags" using primary key columns"""
  template_tags_by_pk(id: Int!): template_tags

  """
  fetch data from the table in a streaming manner: "template_tags"
  """
  template_tags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [template_tags_stream_cursor_input]!

    """filter the rows returned"""
    where: template_tags_bool_exp
  ): [template_tags!]!

  """An array relationship"""
  templates(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): [templates!]!

  """An aggregate relationship"""
  templates_aggregate(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): templates_aggregate!

  """fetch data from the table: "templates" using primary key columns"""
  templates_by_pk(id: uuid!): templates

  """
  fetch data from the table in a streaming manner: "templates"
  """
  templates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [templates_stream_cursor_input]!

    """filter the rows returned"""
    where: templates_bool_exp
  ): [templates!]!

  """
  fetch data from the table: "tokens_history"
  """
  tokens_history(
    """distinct select on columns"""
    distinct_on: [tokens_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_history_order_by!]

    """filter the rows returned"""
    where: tokens_history_bool_exp
  ): [tokens_history!]!

  """
  fetch aggregated fields from the table: "tokens_history"
  """
  tokens_history_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_history_order_by!]

    """filter the rows returned"""
    where: tokens_history_bool_exp
  ): tokens_history_aggregate!

  """fetch data from the table: "tokens_history" using primary key columns"""
  tokens_history_by_pk(id: uuid!): tokens_history

  """
  fetch data from the table in a streaming manner: "tokens_history"
  """
  tokens_history_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokens_history_stream_cursor_input]!

    """filter the rows returned"""
    where: tokens_history_bool_exp
  ): [tokens_history!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!

  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens

  """
  fetch data from the table in a streaming manner: "verification_tokens"
  """
  verification_tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [verification_tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """
  fetch data from the table: "wallets"
  """
  wallets(
    """distinct select on columns"""
    distinct_on: [wallets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wallets_order_by!]

    """filter the rows returned"""
    where: wallets_bool_exp
  ): [wallets!]!

  """
  fetch aggregated fields from the table: "wallets"
  """
  wallets_aggregate(
    """distinct select on columns"""
    distinct_on: [wallets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [wallets_order_by!]

    """filter the rows returned"""
    where: wallets_bool_exp
  ): wallets_aggregate!

  """fetch data from the table: "wallets" using primary key columns"""
  wallets_by_pk(id: uuid!): wallets

  """
  fetch data from the table in a streaming manner: "wallets"
  """
  wallets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [wallets_stream_cursor_input]!

    """filter the rows returned"""
    where: wallets_bool_exp
  ): [wallets!]!
}

"""
columns and relationships of "template_categories"
"""
type template_categories {
  id: Int!
  name: String

  """An array relationship"""
  templates(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): [templates!]!

  """An aggregate relationship"""
  templates_aggregate(
    """distinct select on columns"""
    distinct_on: [templates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [templates_order_by!]

    """filter the rows returned"""
    where: templates_bool_exp
  ): templates_aggregate!
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""
aggregated selection of "template_categories"
"""
type template_categories_aggregate {
  aggregate: template_categories_aggregate_fields
  nodes: [template_categories!]!
}

"""
aggregate fields of "template_categories"
"""
type template_categories_aggregate_fields {
  avg: template_categories_avg_fields
  count(columns: [template_categories_select_column!], distinct: Boolean): Int!
  max: template_categories_max_fields
  min: template_categories_min_fields
  stddev: template_categories_stddev_fields
  stddev_pop: template_categories_stddev_pop_fields
  stddev_samp: template_categories_stddev_samp_fields
  sum: template_categories_sum_fields
  var_pop: template_categories_var_pop_fields
  var_samp: template_categories_var_samp_fields
  variance: template_categories_variance_fields
}

"""aggregate avg on columns"""
type template_categories_avg_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""
Boolean expression to filter rows from the table "template_categories". All fields are combined with a logical 'AND'.
"""
input template_categories_bool_exp {
  _and: [template_categories_bool_exp!]
  _not: template_categories_bool_exp
  _or: [template_categories_bool_exp!]
  id: Int_comparison_exp
  name: String_comparison_exp
  templates: templates_bool_exp
  templates_aggregate: templates_aggregate_bool_exp
  titile: String_comparison_exp
  ui_lg_c: Int_comparison_exp
  ui_lg_w: Int_comparison_exp
  ui_sm_c: String_comparison_exp
  ui_sm_w: Int_comparison_exp
  ui_table_c: Int_comparison_exp
  ui_table_w: Int_comparison_exp
}

"""
unique or primary key constraints on table "template_categories"
"""
enum template_categories_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  template_categories_pkey
}

"""
input type for incrementing numeric columns in table "template_categories"
"""
input template_categories_inc_input {
  id: Int
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""
input type for inserting data into table "template_categories"
"""
input template_categories_insert_input {
  id: Int
  name: String
  templates: templates_arr_rel_insert_input
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""aggregate max on columns"""
type template_categories_max_fields {
  id: Int
  name: String
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""aggregate min on columns"""
type template_categories_min_fields {
  id: Int
  name: String
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""
response of any mutation on the table "template_categories"
"""
type template_categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [template_categories!]!
}

"""
input type for inserting object relation for remote table "template_categories"
"""
input template_categories_obj_rel_insert_input {
  data: template_categories_insert_input!

  """upsert condition"""
  on_conflict: template_categories_on_conflict
}

"""
on_conflict condition type for table "template_categories"
"""
input template_categories_on_conflict {
  constraint: template_categories_constraint!
  update_columns: [template_categories_update_column!]! = []
  where: template_categories_bool_exp
}

"""Ordering options when selecting data from "template_categories"."""
input template_categories_order_by {
  id: order_by
  name: order_by
  templates_aggregate: templates_aggregate_order_by
  titile: order_by
  ui_lg_c: order_by
  ui_lg_w: order_by
  ui_sm_c: order_by
  ui_sm_w: order_by
  ui_table_c: order_by
  ui_table_w: order_by
}

"""primary key columns input for table: template_categories"""
input template_categories_pk_columns_input {
  id: Int!
}

"""
select columns of table "template_categories"
"""
enum template_categories_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  titile

  """column name"""
  ui_lg_c

  """column name"""
  ui_lg_w

  """column name"""
  ui_sm_c

  """column name"""
  ui_sm_w

  """column name"""
  ui_table_c

  """column name"""
  ui_table_w
}

"""
input type for updating data in table "template_categories"
"""
input template_categories_set_input {
  id: Int
  name: String
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""aggregate stddev on columns"""
type template_categories_stddev_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""aggregate stddev_pop on columns"""
type template_categories_stddev_pop_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""aggregate stddev_samp on columns"""
type template_categories_stddev_samp_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""
Streaming cursor of the table "template_categories"
"""
input template_categories_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: template_categories_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input template_categories_stream_cursor_value_input {
  id: Int
  name: String
  titile: String
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_c: String
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""aggregate sum on columns"""
type template_categories_sum_fields {
  id: Int
  ui_lg_c: Int
  ui_lg_w: Int
  ui_sm_w: Int
  ui_table_c: Int
  ui_table_w: Int
}

"""
update columns of table "template_categories"
"""
enum template_categories_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  titile

  """column name"""
  ui_lg_c

  """column name"""
  ui_lg_w

  """column name"""
  ui_sm_c

  """column name"""
  ui_sm_w

  """column name"""
  ui_table_c

  """column name"""
  ui_table_w
}

input template_categories_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: template_categories_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: template_categories_set_input

  """filter the rows which have to be updated"""
  where: template_categories_bool_exp!
}

"""aggregate var_pop on columns"""
type template_categories_var_pop_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""aggregate var_samp on columns"""
type template_categories_var_samp_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""aggregate variance on columns"""
type template_categories_variance_fields {
  id: Float
  ui_lg_c: Float
  ui_lg_w: Float
  ui_sm_w: Float
  ui_table_c: Float
  ui_table_w: Float
}

"""
columns and relationships of "template_tags"
"""
type template_tags {
  id: Int!
  name: String
  title: String
}

"""
aggregated selection of "template_tags"
"""
type template_tags_aggregate {
  aggregate: template_tags_aggregate_fields
  nodes: [template_tags!]!
}

"""
aggregate fields of "template_tags"
"""
type template_tags_aggregate_fields {
  avg: template_tags_avg_fields
  count(columns: [template_tags_select_column!], distinct: Boolean): Int!
  max: template_tags_max_fields
  min: template_tags_min_fields
  stddev: template_tags_stddev_fields
  stddev_pop: template_tags_stddev_pop_fields
  stddev_samp: template_tags_stddev_samp_fields
  sum: template_tags_sum_fields
  var_pop: template_tags_var_pop_fields
  var_samp: template_tags_var_samp_fields
  variance: template_tags_variance_fields
}

"""aggregate avg on columns"""
type template_tags_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "template_tags". All fields are combined with a logical 'AND'.
"""
input template_tags_bool_exp {
  _and: [template_tags_bool_exp!]
  _not: template_tags_bool_exp
  _or: [template_tags_bool_exp!]
  id: Int_comparison_exp
  name: String_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "template_tags"
"""
enum template_tags_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  template_tags_pkey
}

"""
input type for incrementing numeric columns in table "template_tags"
"""
input template_tags_inc_input {
  id: Int
}

"""
input type for inserting data into table "template_tags"
"""
input template_tags_insert_input {
  id: Int
  name: String
  title: String
}

"""aggregate max on columns"""
type template_tags_max_fields {
  id: Int
  name: String
  title: String
}

"""aggregate min on columns"""
type template_tags_min_fields {
  id: Int
  name: String
  title: String
}

"""
response of any mutation on the table "template_tags"
"""
type template_tags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [template_tags!]!
}

"""
on_conflict condition type for table "template_tags"
"""
input template_tags_on_conflict {
  constraint: template_tags_constraint!
  update_columns: [template_tags_update_column!]! = []
  where: template_tags_bool_exp
}

"""Ordering options when selecting data from "template_tags"."""
input template_tags_order_by {
  id: order_by
  name: order_by
  title: order_by
}

"""primary key columns input for table: template_tags"""
input template_tags_pk_columns_input {
  id: Int!
}

"""
select columns of table "template_tags"
"""
enum template_tags_select_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

"""
input type for updating data in table "template_tags"
"""
input template_tags_set_input {
  id: Int
  name: String
  title: String
}

"""aggregate stddev on columns"""
type template_tags_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type template_tags_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type template_tags_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "template_tags"
"""
input template_tags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: template_tags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input template_tags_stream_cursor_value_input {
  id: Int
  name: String
  title: String
}

"""aggregate sum on columns"""
type template_tags_sum_fields {
  id: Int
}

"""
update columns of table "template_tags"
"""
enum template_tags_update_column {
  """column name"""
  id

  """column name"""
  name

  """column name"""
  title
}

input template_tags_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: template_tags_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: template_tags_set_input

  """filter the rows which have to be updated"""
  where: template_tags_bool_exp!
}

"""aggregate var_pop on columns"""
type template_tags_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type template_tags_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type template_tags_variance_fields {
  id: Float
}

"""
columns and relationships of "templates"
"""
type templates {
  description: String

  """An object relationship"""
  directus_file: directus_files
  filelds(
    """JSON select path"""
    path: String
  ): json
  group_id: Int
  icon: uuid
  id: uuid!
  name: String
  promt: String

  """An object relationship"""
  template_category: template_categories
  title: String
}

"""
aggregated selection of "templates"
"""
type templates_aggregate {
  aggregate: templates_aggregate_fields
  nodes: [templates!]!
}

input templates_aggregate_bool_exp {
  count: templates_aggregate_bool_exp_count
}

input templates_aggregate_bool_exp_count {
  arguments: [templates_select_column!]
  distinct: Boolean
  filter: templates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "templates"
"""
type templates_aggregate_fields {
  avg: templates_avg_fields
  count(columns: [templates_select_column!], distinct: Boolean): Int!
  max: templates_max_fields
  min: templates_min_fields
  stddev: templates_stddev_fields
  stddev_pop: templates_stddev_pop_fields
  stddev_samp: templates_stddev_samp_fields
  sum: templates_sum_fields
  var_pop: templates_var_pop_fields
  var_samp: templates_var_samp_fields
  variance: templates_variance_fields
}

"""
order by aggregate values of table "templates"
"""
input templates_aggregate_order_by {
  avg: templates_avg_order_by
  count: order_by
  max: templates_max_order_by
  min: templates_min_order_by
  stddev: templates_stddev_order_by
  stddev_pop: templates_stddev_pop_order_by
  stddev_samp: templates_stddev_samp_order_by
  sum: templates_sum_order_by
  var_pop: templates_var_pop_order_by
  var_samp: templates_var_samp_order_by
  variance: templates_variance_order_by
}

"""
input type for inserting array relation for remote table "templates"
"""
input templates_arr_rel_insert_input {
  data: [templates_insert_input!]!

  """upsert condition"""
  on_conflict: templates_on_conflict
}

"""aggregate avg on columns"""
type templates_avg_fields {
  group_id: Float
}

"""
order by avg() on columns of table "templates"
"""
input templates_avg_order_by {
  group_id: order_by
}

"""
Boolean expression to filter rows from the table "templates". All fields are combined with a logical 'AND'.
"""
input templates_bool_exp {
  _and: [templates_bool_exp!]
  _not: templates_bool_exp
  _or: [templates_bool_exp!]
  description: String_comparison_exp
  directus_file: directus_files_bool_exp
  filelds: json_comparison_exp
  group_id: Int_comparison_exp
  icon: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  promt: String_comparison_exp
  template_category: template_categories_bool_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "templates"
"""
enum templates_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  templates_pkey

  """
  unique or primary key constraint on columns "id"
  """
  templates_uid_key
}

"""
input type for incrementing numeric columns in table "templates"
"""
input templates_inc_input {
  group_id: Int
}

"""
input type for inserting data into table "templates"
"""
input templates_insert_input {
  description: String
  directus_file: directus_files_obj_rel_insert_input
  filelds: json
  group_id: Int
  icon: uuid
  id: uuid
  name: String
  promt: String
  template_category: template_categories_obj_rel_insert_input
  title: String
}

"""aggregate max on columns"""
type templates_max_fields {
  description: String
  group_id: Int
  icon: uuid
  id: uuid
  name: String
  promt: String
  title: String
}

"""
order by max() on columns of table "templates"
"""
input templates_max_order_by {
  description: order_by
  group_id: order_by
  icon: order_by
  id: order_by
  name: order_by
  promt: order_by
  title: order_by
}

"""aggregate min on columns"""
type templates_min_fields {
  description: String
  group_id: Int
  icon: uuid
  id: uuid
  name: String
  promt: String
  title: String
}

"""
order by min() on columns of table "templates"
"""
input templates_min_order_by {
  description: order_by
  group_id: order_by
  icon: order_by
  id: order_by
  name: order_by
  promt: order_by
  title: order_by
}

"""
response of any mutation on the table "templates"
"""
type templates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [templates!]!
}

"""
on_conflict condition type for table "templates"
"""
input templates_on_conflict {
  constraint: templates_constraint!
  update_columns: [templates_update_column!]! = []
  where: templates_bool_exp
}

"""Ordering options when selecting data from "templates"."""
input templates_order_by {
  description: order_by
  directus_file: directus_files_order_by
  filelds: order_by
  group_id: order_by
  icon: order_by
  id: order_by
  name: order_by
  promt: order_by
  template_category: template_categories_order_by
  title: order_by
}

"""primary key columns input for table: templates"""
input templates_pk_columns_input {
  id: uuid!
}

"""
select columns of table "templates"
"""
enum templates_select_column {
  """column name"""
  description

  """column name"""
  filelds

  """column name"""
  group_id

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  promt

  """column name"""
  title
}

"""
input type for updating data in table "templates"
"""
input templates_set_input {
  description: String
  filelds: json
  group_id: Int
  icon: uuid
  id: uuid
  name: String
  promt: String
  title: String
}

"""aggregate stddev on columns"""
type templates_stddev_fields {
  group_id: Float
}

"""
order by stddev() on columns of table "templates"
"""
input templates_stddev_order_by {
  group_id: order_by
}

"""aggregate stddev_pop on columns"""
type templates_stddev_pop_fields {
  group_id: Float
}

"""
order by stddev_pop() on columns of table "templates"
"""
input templates_stddev_pop_order_by {
  group_id: order_by
}

"""aggregate stddev_samp on columns"""
type templates_stddev_samp_fields {
  group_id: Float
}

"""
order by stddev_samp() on columns of table "templates"
"""
input templates_stddev_samp_order_by {
  group_id: order_by
}

"""
Streaming cursor of the table "templates"
"""
input templates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: templates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input templates_stream_cursor_value_input {
  description: String
  filelds: json
  group_id: Int
  icon: uuid
  id: uuid
  name: String
  promt: String
  title: String
}

"""aggregate sum on columns"""
type templates_sum_fields {
  group_id: Int
}

"""
order by sum() on columns of table "templates"
"""
input templates_sum_order_by {
  group_id: order_by
}

"""
update columns of table "templates"
"""
enum templates_update_column {
  """column name"""
  description

  """column name"""
  filelds

  """column name"""
  group_id

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  promt

  """column name"""
  title
}

input templates_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: templates_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: templates_set_input

  """filter the rows which have to be updated"""
  where: templates_bool_exp!
}

"""aggregate var_pop on columns"""
type templates_var_pop_fields {
  group_id: Float
}

"""
order by var_pop() on columns of table "templates"
"""
input templates_var_pop_order_by {
  group_id: order_by
}

"""aggregate var_samp on columns"""
type templates_var_samp_fields {
  group_id: Float
}

"""
order by var_samp() on columns of table "templates"
"""
input templates_var_samp_order_by {
  group_id: order_by
}

"""aggregate variance on columns"""
type templates_variance_fields {
  group_id: Float
}

"""
order by variance() on columns of table "templates"
"""
input templates_variance_order_by {
  group_id: order_by
}

type TemplatesWeaviates {
  _additional: TemplatesWeaviatesAdditional
  description: String
  name: String
  title: String
}

type TemplatesWeaviatesAdditional {
  answer: TemplatesWeaviatesAdditionalAnswer
  certainty: Float
  classification: TemplatesWeaviatesAdditionalClassification
  creationTimeUnix: String
  distance: Float
  explainScore: String
  featureProjection(algorithm: String, dimensions: Int, iterations: Int, learningRate: Int, perplexity: Int): TemplatesWeaviatesAdditionalFeatureProjection
  group: TemplatesWeaviatesAdditionalGroup

  """The UUID of a Object, assigned by its local Weaviate"""
  id: String
  lastUpdateTimeUnix: String
  rerank(
    """Property to rank from"""
    property: String

    """Properties which contains text"""
    query: String
  ): [TemplatesWeaviatesAdditionalReranker]
  score: String
  vector: [Float]
}

type TemplatesWeaviatesAdditionalAnswer {
  endPosition: Int
  hasAnswer: Boolean
  property: String
  result: String
  startPosition: Int
}

type TemplatesWeaviatesAdditionalClassification {
  basedOn: [String]
  classifiedFields: [String]
  completed: String
  id: String
  scope: [String]
}

type TemplatesWeaviatesAdditionalFeatureProjection {
  vector: [Float]
}

type TemplatesWeaviatesAdditionalGroup {
  count: Int
  groupedBy: TemplatesWeaviatesAdditionalGroupGroupedBy
  hits: [TemplatesWeaviatesAdditionalGroupHits]
  id: Int
  maxDistance: Float
  minDistance: Float
}

type TemplatesWeaviatesAdditionalGroupGroupedBy {
  path: [String]
  value: String
}

type TemplatesWeaviatesAdditionalGroupHits {
  _additional: TemplatesWeaviatesAdditionalGroupHitsAdditional
  description: String
  name: String
  title: String
}

type TemplatesWeaviatesAdditionalGroupHitsAdditional {
  distance: Float
  id: String
  vector: [Float]
}

type TemplatesWeaviatesAdditionalReranker {
  score: Float
}

"""String or String[]"""
scalar TextAggregateObjectsChatsWeaviate

"""String or String[]"""
scalar TextAggregateObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextAggregateObjectsMessagesWeaviate

"""String or String[]"""
scalar TextAggregateObjectsRolesWeaviate

"""String or String[]"""
scalar TextAggregateObjectsTemplatesWeaviates

"""String or String[]"""
scalar TextDateAggregateObjectsChatsWeaviate

"""String or String[]"""
scalar TextDateAggregateObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextDateAggregateObjectsMessagesWeaviate

"""String or String[]"""
scalar TextDateAggregateObjectsRolesWeaviate

"""String or String[]"""
scalar TextDateAggregateObjectsTemplatesWeaviates

"""String or String[]"""
scalar TextDateGetObjectsChatsWeaviate

"""String or String[]"""
scalar TextDateGetObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextDateGetObjectsMessagesWeaviate

"""String or String[]"""
scalar TextDateGetObjectsRolesWeaviate

"""String or String[]"""
scalar TextDateGetObjectsTemplatesWeaviates

"""String or String[]"""
scalar TextGetObjectsChatsWeaviate

"""String or String[]"""
scalar TextGetObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextGetObjectsMessagesWeaviate

"""String or String[]"""
scalar TextGetObjectsRolesWeaviate

"""String or String[]"""
scalar TextGetObjectsTemplatesWeaviates

"""String or String[]"""
scalar TextStringAggregateObjectsChatsWeaviate

"""String or String[]"""
scalar TextStringAggregateObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextStringAggregateObjectsMessagesWeaviate

"""String or String[]"""
scalar TextStringAggregateObjectsRolesWeaviate

"""String or String[]"""
scalar TextStringAggregateObjectsTemplatesWeaviates

"""String or String[]"""
scalar TextStringGetObjectsChatsWeaviate

"""String or String[]"""
scalar TextStringGetObjectsDocumentsWeaviates

"""String or String[]"""
scalar TextStringGetObjectsMessagesWeaviate

"""String or String[]"""
scalar TextStringGetObjectsRolesWeaviate

"""String or String[]"""
scalar TextStringGetObjectsTemplatesWeaviates

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "tokens_history"
"""
type tokens_history {
  additional_tokens: Int
  date: timestamptz!
  id: uuid!
  tokens: Int!
  user_id: uuid!
}

"""
aggregated selection of "tokens_history"
"""
type tokens_history_aggregate {
  aggregate: tokens_history_aggregate_fields
  nodes: [tokens_history!]!
}

"""
aggregate fields of "tokens_history"
"""
type tokens_history_aggregate_fields {
  avg: tokens_history_avg_fields
  count(columns: [tokens_history_select_column!], distinct: Boolean): Int!
  max: tokens_history_max_fields
  min: tokens_history_min_fields
  stddev: tokens_history_stddev_fields
  stddev_pop: tokens_history_stddev_pop_fields
  stddev_samp: tokens_history_stddev_samp_fields
  sum: tokens_history_sum_fields
  var_pop: tokens_history_var_pop_fields
  var_samp: tokens_history_var_samp_fields
  variance: tokens_history_variance_fields
}

"""aggregate avg on columns"""
type tokens_history_avg_fields {
  additional_tokens: Float
  tokens: Float
}

"""
Boolean expression to filter rows from the table "tokens_history". All fields are combined with a logical 'AND'.
"""
input tokens_history_bool_exp {
  _and: [tokens_history_bool_exp!]
  _not: tokens_history_bool_exp
  _or: [tokens_history_bool_exp!]
  additional_tokens: Int_comparison_exp
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  tokens: Int_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tokens_history"
"""
enum tokens_history_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tokens_history_pkey
}

"""
input type for incrementing numeric columns in table "tokens_history"
"""
input tokens_history_inc_input {
  additional_tokens: Int
  tokens: Int
}

"""
input type for inserting data into table "tokens_history"
"""
input tokens_history_insert_input {
  additional_tokens: Int
  date: timestamptz
  id: uuid
  tokens: Int
  user_id: uuid
}

"""aggregate max on columns"""
type tokens_history_max_fields {
  additional_tokens: Int
  date: timestamptz
  id: uuid
  tokens: Int
  user_id: uuid
}

"""aggregate min on columns"""
type tokens_history_min_fields {
  additional_tokens: Int
  date: timestamptz
  id: uuid
  tokens: Int
  user_id: uuid
}

"""
response of any mutation on the table "tokens_history"
"""
type tokens_history_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tokens_history!]!
}

"""
on_conflict condition type for table "tokens_history"
"""
input tokens_history_on_conflict {
  constraint: tokens_history_constraint!
  update_columns: [tokens_history_update_column!]! = []
  where: tokens_history_bool_exp
}

"""Ordering options when selecting data from "tokens_history"."""
input tokens_history_order_by {
  additional_tokens: order_by
  date: order_by
  id: order_by
  tokens: order_by
  user_id: order_by
}

"""primary key columns input for table: tokens_history"""
input tokens_history_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tokens_history"
"""
enum tokens_history_select_column {
  """column name"""
  additional_tokens

  """column name"""
  date

  """column name"""
  id

  """column name"""
  tokens

  """column name"""
  user_id
}

"""
input type for updating data in table "tokens_history"
"""
input tokens_history_set_input {
  additional_tokens: Int
  date: timestamptz
  id: uuid
  tokens: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type tokens_history_stddev_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate stddev_pop on columns"""
type tokens_history_stddev_pop_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate stddev_samp on columns"""
type tokens_history_stddev_samp_fields {
  additional_tokens: Float
  tokens: Float
}

"""
Streaming cursor of the table "tokens_history"
"""
input tokens_history_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokens_history_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokens_history_stream_cursor_value_input {
  additional_tokens: Int
  date: timestamptz
  id: uuid
  tokens: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type tokens_history_sum_fields {
  additional_tokens: Int
  tokens: Int
}

"""
update columns of table "tokens_history"
"""
enum tokens_history_update_column {
  """column name"""
  additional_tokens

  """column name"""
  date

  """column name"""
  id

  """column name"""
  tokens

  """column name"""
  user_id
}

input tokens_history_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: tokens_history_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: tokens_history_set_input

  """filter the rows which have to be updated"""
  where: tokens_history_bool_exp!
}

"""aggregate var_pop on columns"""
type tokens_history_var_pop_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate var_samp on columns"""
type tokens_history_var_samp_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate variance on columns"""
type tokens_history_variance_fields {
  additional_tokens: Float
  tokens: Float
}

"""
columns and relationships of "users"
"""
type users {
  """An object relationship"""
  accounts: accounts
  ai_text_model: String
  card_token: String

  """An array relationship"""
  chats(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): [chats!]!

  """An aggregate relationship"""
  chats_aggregate(
    """distinct select on columns"""
    distinct_on: [chats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chats_order_by!]

    """filter the rows returned"""
    where: chats_bool_exp
  ): chats_aggregate!
  date_end_plan: timestamptz

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!
  email: String!
  emailVerified: timestamptz
  id: uuid!
  image: String
  is_client: Boolean
  is_former_client: Boolean
  is_subscriber: Boolean
  is_year_sub: Boolean
  name: String
  plan_id: uuid

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!
  subscription_id: String
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  accounts: accounts_bool_exp
  ai_text_model: String_comparison_exp
  card_token: String_comparison_exp
  chats: chats_bool_exp
  chats_aggregate: chats_aggregate_bool_exp
  date_end_plan: timestamptz_comparison_exp
  documents: documents_bool_exp
  documents_aggregate: documents_aggregate_bool_exp
  email: String_comparison_exp
  emailVerified: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  is_client: Boolean_comparison_exp
  is_former_client: Boolean_comparison_exp
  is_subscriber: Boolean_comparison_exp
  is_year_sub: Boolean_comparison_exp
  name: String_comparison_exp
  plan_id: uuid_comparison_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
  subscription_id: String_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  accounts: accounts_obj_rel_insert_input
  ai_text_model: String
  card_token: String
  chats: chats_arr_rel_insert_input
  date_end_plan: timestamptz
  documents: documents_arr_rel_insert_input
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  is_client: Boolean
  is_former_client: Boolean
  is_subscriber: Boolean
  is_year_sub: Boolean
  name: String
  plan_id: uuid
  sessions: sessions_arr_rel_insert_input
  subscription_id: String
}

"""aggregate max on columns"""
type users_max_fields {
  ai_text_model: String
  card_token: String
  date_end_plan: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  plan_id: uuid
  subscription_id: String
}

"""aggregate min on columns"""
type users_min_fields {
  ai_text_model: String
  card_token: String
  date_end_plan: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  plan_id: uuid
  subscription_id: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  accounts: accounts_order_by
  ai_text_model: order_by
  card_token: order_by
  chats_aggregate: chats_aggregate_order_by
  date_end_plan: order_by
  documents_aggregate: documents_aggregate_order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  image: order_by
  is_client: order_by
  is_former_client: order_by
  is_subscriber: order_by
  is_year_sub: order_by
  name: order_by
  plan_id: order_by
  sessions_aggregate: sessions_aggregate_order_by
  subscription_id: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  ai_text_model

  """column name"""
  card_token

  """column name"""
  date_end_plan

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_client

  """column name"""
  is_former_client

  """column name"""
  is_subscriber

  """column name"""
  is_year_sub

  """column name"""
  name

  """column name"""
  plan_id

  """column name"""
  subscription_id
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  ai_text_model: String
  card_token: String
  date_end_plan: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  is_client: Boolean
  is_former_client: Boolean
  is_subscriber: Boolean
  is_year_sub: Boolean
  name: String
  plan_id: uuid
  subscription_id: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  ai_text_model: String
  card_token: String
  date_end_plan: timestamptz
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  is_client: Boolean
  is_former_client: Boolean
  is_subscriber: Boolean
  is_year_sub: Boolean
  name: String
  plan_id: uuid
  subscription_id: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  ai_text_model

  """column name"""
  card_token

  """column name"""
  date_end_plan

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_client

  """column name"""
  is_former_client

  """column name"""
  is_subscriber

  """column name"""
  is_year_sub

  """column name"""
  name

  """column name"""
  plan_id

  """column name"""
  subscription_id
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "verification_tokens"
"""
type verification_tokens {
  expires: timestamptz!
  identifier: String!
  token: String!
}

"""
aggregated selection of "verification_tokens"
"""
type verification_tokens_aggregate {
  aggregate: verification_tokens_aggregate_fields
  nodes: [verification_tokens!]!
}

"""
aggregate fields of "verification_tokens"
"""
type verification_tokens_aggregate_fields {
  count(columns: [verification_tokens_select_column!], distinct: Boolean): Int!
  max: verification_tokens_max_fields
  min: verification_tokens_min_fields
}

"""
Boolean expression to filter rows from the table "verification_tokens". All fields are combined with a logical 'AND'.
"""
input verification_tokens_bool_exp {
  _and: [verification_tokens_bool_exp!]
  _not: verification_tokens_bool_exp
  _or: [verification_tokens_bool_exp!]
  expires: timestamptz_comparison_exp
  identifier: String_comparison_exp
  token: String_comparison_exp
}

"""
unique or primary key constraints on table "verification_tokens"
"""
enum verification_tokens_constraint {
  """
  unique or primary key constraint on columns "token"
  """
  verification_tokens_pkey
}

"""
input type for inserting data into table "verification_tokens"
"""
input verification_tokens_insert_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""aggregate max on columns"""
type verification_tokens_max_fields {
  expires: timestamptz
  identifier: String
  token: String
}

"""aggregate min on columns"""
type verification_tokens_min_fields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
response of any mutation on the table "verification_tokens"
"""
type verification_tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [verification_tokens!]!
}

"""
on_conflict condition type for table "verification_tokens"
"""
input verification_tokens_on_conflict {
  constraint: verification_tokens_constraint!
  update_columns: [verification_tokens_update_column!]! = []
  where: verification_tokens_bool_exp
}

"""Ordering options when selecting data from "verification_tokens"."""
input verification_tokens_order_by {
  expires: order_by
  identifier: order_by
  token: order_by
}

"""primary key columns input for table: verification_tokens"""
input verification_tokens_pk_columns_input {
  token: String!
}

"""
select columns of table "verification_tokens"
"""
enum verification_tokens_select_column {
  """column name"""
  expires

  """column name"""
  identifier

  """column name"""
  token
}

"""
input type for updating data in table "verification_tokens"
"""
input verification_tokens_set_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""
Streaming cursor of the table "verification_tokens"
"""
input verification_tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: verification_tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input verification_tokens_stream_cursor_value_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""
update columns of table "verification_tokens"
"""
enum verification_tokens_update_column {
  """column name"""
  expires

  """column name"""
  identifier

  """column name"""
  token
}

input verification_tokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: verification_tokens_set_input

  """filter the rows which have to be updated"""
  where: verification_tokens_bool_exp!
}

"""
columns and relationships of "wallets"
"""
type wallets {
  additional_tokens: Int
  id: uuid!
  last_use: timestamptz!
  tokens: Int!
  user_id: uuid!

  """An object relationship"""
  users: users
}

"""
aggregated selection of "wallets"
"""
type wallets_aggregate {
  aggregate: wallets_aggregate_fields
  nodes: [wallets!]!
}

"""
aggregate fields of "wallets"
"""
type wallets_aggregate_fields {
  avg: wallets_avg_fields
  count(columns: [wallets_select_column!], distinct: Boolean): Int!
  max: wallets_max_fields
  min: wallets_min_fields
  stddev: wallets_stddev_fields
  stddev_pop: wallets_stddev_pop_fields
  stddev_samp: wallets_stddev_samp_fields
  sum: wallets_sum_fields
  var_pop: wallets_var_pop_fields
  var_samp: wallets_var_samp_fields
  variance: wallets_variance_fields
}

"""aggregate avg on columns"""
type wallets_avg_fields {
  additional_tokens: Float
  tokens: Float
}

"""
Boolean expression to filter rows from the table "wallets". All fields are combined with a logical 'AND'.
"""
input wallets_bool_exp {
  _and: [wallets_bool_exp!]
  _not: wallets_bool_exp
  _or: [wallets_bool_exp!]
  additional_tokens: Int_comparison_exp
  id: uuid_comparison_exp
  last_use: timestamptz_comparison_exp
  tokens: Int_comparison_exp
  user_id: uuid_comparison_exp
  users: users_bool_exp
}

"""
unique or primary key constraints on table "wallets"
"""
enum wallets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  wallets_pkey
}

"""
input type for incrementing numeric columns in table "wallets"
"""
input wallets_inc_input {
  additional_tokens: Int
  tokens: Int
}

"""
input type for inserting data into table "wallets"
"""
input wallets_insert_input {
  additional_tokens: Int
  id: uuid
  last_use: timestamptz
  tokens: Int
  user_id: uuid
  users: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type wallets_max_fields {
  additional_tokens: Int
  id: uuid
  last_use: timestamptz
  tokens: Int
  user_id: uuid
}

"""aggregate min on columns"""
type wallets_min_fields {
  additional_tokens: Int
  id: uuid
  last_use: timestamptz
  tokens: Int
  user_id: uuid
}

"""
response of any mutation on the table "wallets"
"""
type wallets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [wallets!]!
}

"""
on_conflict condition type for table "wallets"
"""
input wallets_on_conflict {
  constraint: wallets_constraint!
  update_columns: [wallets_update_column!]! = []
  where: wallets_bool_exp
}

"""Ordering options when selecting data from "wallets"."""
input wallets_order_by {
  additional_tokens: order_by
  id: order_by
  last_use: order_by
  tokens: order_by
  user_id: order_by
  users: users_order_by
}

"""primary key columns input for table: wallets"""
input wallets_pk_columns_input {
  id: uuid!
}

"""
select columns of table "wallets"
"""
enum wallets_select_column {
  """column name"""
  additional_tokens

  """column name"""
  id

  """column name"""
  last_use

  """column name"""
  tokens

  """column name"""
  user_id
}

"""
input type for updating data in table "wallets"
"""
input wallets_set_input {
  additional_tokens: Int
  id: uuid
  last_use: timestamptz
  tokens: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type wallets_stddev_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate stddev_pop on columns"""
type wallets_stddev_pop_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate stddev_samp on columns"""
type wallets_stddev_samp_fields {
  additional_tokens: Float
  tokens: Float
}

"""
Streaming cursor of the table "wallets"
"""
input wallets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: wallets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input wallets_stream_cursor_value_input {
  additional_tokens: Int
  id: uuid
  last_use: timestamptz
  tokens: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type wallets_sum_fields {
  additional_tokens: Int
  tokens: Int
}

"""
update columns of table "wallets"
"""
enum wallets_update_column {
  """column name"""
  additional_tokens

  """column name"""
  id

  """column name"""
  last_use

  """column name"""
  tokens

  """column name"""
  user_id
}

input wallets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: wallets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: wallets_set_input

  """filter the rows which have to be updated"""
  where: wallets_bool_exp!
}

"""aggregate var_pop on columns"""
type wallets_var_pop_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate var_samp on columns"""
type wallets_var_samp_fields {
  additional_tokens: Float
  tokens: Float
}

"""aggregate variance on columns"""
type wallets_variance_fields {
  additional_tokens: Float
  tokens: Float
}

